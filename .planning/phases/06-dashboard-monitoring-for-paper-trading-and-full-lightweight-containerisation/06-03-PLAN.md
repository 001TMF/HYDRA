---
phase: 06-dashboard-monitoring-for-paper-trading-and-full-lightweight-containerisation
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/hydra/dashboard/routes/pages.py
  - src/hydra/dashboard/routes/api.py
  - src/hydra/dashboard/routes/sse.py
  - src/hydra/dashboard/templates/index.html
  - src/hydra/dashboard/templates/fills.html
  - src/hydra/dashboard/templates/agent.html
  - src/hydra/dashboard/templates/drift.html
  - src/hydra/dashboard/templates/system.html
  - src/hydra/dashboard/app.py
autonomous: true
requirements: []

must_haves:
  truths:
    - "Overview page shows fill count, agent state, and latest cycle timestamp"
    - "Fills page displays a table of recent fills with slippage columns"
    - "Agent page shows experiment journal entries and agent loop state"
    - "Drift page displays drift report metrics from DriftObserver"
    - "System page shows broker connection status, risk gate config, and reconciliation stats"
    - "Dashboard pages auto-refresh via htmx polling every 60 seconds"
    - "SSE streams cycle status updates to the overview page"
    - "PaperTradingRunner starts as a FastAPI lifespan event when HYDRA_START_RUNNER=true"
  artifacts:
    - path: "src/hydra/dashboard/templates/index.html"
      provides: "Overview dashboard with fill count, agent state, cycle summary"
      contains: "hx-get"
    - path: "src/hydra/dashboard/templates/fills.html"
      provides: "Fill journal table with slippage data and reconciliation summary"
      contains: "hx-get"
    - path: "src/hydra/dashboard/templates/agent.html"
      provides: "Agent loop status and experiment journal history"
    - path: "src/hydra/dashboard/templates/drift.html"
      provides: "Drift metrics: Sharpe, drawdown, hit rate, feature drift"
    - path: "src/hydra/dashboard/templates/system.html"
      provides: "System health: broker status, risk config, reconciliation"
    - path: "src/hydra/dashboard/routes/pages.py"
      provides: "Page routes for all 5 dashboard views"
    - path: "src/hydra/dashboard/routes/api.py"
      provides: "JSON API endpoints for fill data, agent status, drift, system info"
    - path: "src/hydra/dashboard/app.py"
      provides: "Lifespan context manager for PaperTradingRunner integration"
      contains: "_lifespan"
  key_links:
    - from: "src/hydra/dashboard/routes/pages.py"
      to: "src/hydra/execution/fill_journal.py"
      via: "FillJournal.get_fills() for fill table rendering"
      pattern: "FillJournal"
    - from: "src/hydra/dashboard/routes/pages.py"
      to: "src/hydra/sandbox/journal.py"
      via: "ExperimentJournal.query() for experiment history"
      pattern: "ExperimentJournal"
    - from: "src/hydra/dashboard/routes/api.py"
      to: "src/hydra/execution/reconciler.py"
      via: "SlippageReconciler.reconcile() for reconciliation stats"
      pattern: "SlippageReconciler"
    - from: "src/hydra/dashboard/templates/index.html"
      to: "src/hydra/dashboard/routes/sse.py"
      via: "SSE connection for live cycle updates"
      pattern: "sse-connect"
    - from: "src/hydra/dashboard/app.py"
      to: "src/hydra/execution/runner.py"
      via: "Lifespan context manager starts PaperTradingRunner"
      pattern: "_lifespan"
---

<objective>
Build all five dashboard page templates and their backing API endpoints. Each page reads from existing HYDRA data stores (FillJournal, ExperimentJournal, DriftObserver, agent state) and renders using Jinja2 with htmx auto-refresh.

Purpose: Provide a web-based monitoring interface that replaces manual `hydra status`, `hydra fill-report`, and `hydra diagnose` CLI commands for continuous paper trading monitoring.
Output: 5 complete dashboard pages with htmx auto-refresh and SSE integration, backed by JSON API endpoints.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dashboard-monitoring-for-paper-trading-and-full-lightweight-containerisation/06-RESEARCH.md
@.planning/phases/06-dashboard-monitoring-for-paper-trading-and-full-lightweight-containerisation/06-01-SUMMARY.md
@src/hydra/execution/fill_journal.py
@src/hydra/execution/reconciler.py
@src/hydra/sandbox/journal.py
@src/hydra/sandbox/observer.py
@src/hydra/cli/state.py
@src/hydra/cli/formatters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create page routes and API endpoints for all 5 dashboard views</name>
  <files>
    src/hydra/dashboard/routes/pages.py
    src/hydra/dashboard/routes/api.py
    src/hydra/dashboard/routes/sse.py
  </files>
  <action>
    **Update `src/hydra/dashboard/routes/pages.py`** (replace the stub from 06-01):

    Create 5 page routes, each reading from existing data stores. All database access is wrapped in try/except to handle missing DBs gracefully (dashboard should never crash -- show "No data" instead).

    Helper function `_open_fill_journal(data_dir: Path) -> FillJournal | None` -- tries to open, returns None on failure. Same pattern for `_open_experiment_journal`.

    1. `GET /` (index) -- Overview page:
       - Read fill count from FillJournal (or 0 if unavailable)
       - Read agent state from `get_state()`
       - Read last 3 fills for "recent activity"
       - Render `index.html` with `fill_count`, `agent_state`, `recent_fills`

    2. `GET /fills` -- Fill journal page:
       - Read fills from FillJournal: `get_fills(limit=50)` (or empty list)
       - Read fill count
       - Try SlippageReconciler.reconcile() for summary stats (or None)
       - Render `fills.html` with `fills`, `fill_count`, `reconciliation`

    3. `GET /agent` -- Agent loop status page:
       - Read agent state
       - Read recent experiments from ExperimentJournal: `query(limit=20)` (or empty list)
       - Read experiment count
       - Render `agent.html` with `agent_state`, `experiments`, `experiment_count`

    4. `GET /drift` -- Drift monitoring page:
       - For Phase 6, the dashboard displays whatever drift data is available.
       - Since DriftObserver requires numpy arrays (not stored in DB), the drift page shows a "Drift report generated on demand via CLI" message with a summary of what the observer monitors.
       - Render `drift.html` with static descriptions of monitored metrics (Sharpe, drawdown, hit rate, calibration, PSI, KS, ADWIN, CUSUM). The real-time drift data comes from the agent loop's daily cycle, not from the dashboard querying live.

    5. `GET /system` -- System health page:
       - Read agent state
       - Check fill journal and experiment journal accessibility
       - Try to read reconciliation report if enough fills exist
       - Render `system.html` with `agent_state`, `db_status` dict, `reconciliation`

    **Update `src/hydra/dashboard/routes/api.py`** (extend the 06-01 endpoints):

    Add JSON API endpoints that power htmx partial updates:

    1. `GET /fills/recent` -- returns HTML fragment (not JSON) of last 5 fills as table rows. Set `response_class=HTMLResponse`. The htmx `hx-get` will swap this fragment into the page. Use `app.state.templates` to render a `_fills_rows.html` partial (or use inline string template via Jinja2 `from_string` to avoid an extra template file -- prefer the inline approach for simple fragments).

    2. `GET /agent/state` -- returns HTML fragment with agent state badge. HTMLResponse.

    3. `GET /system/status` -- returns JSON with DB accessibility and agent state (for the system page htmx refresh).

    **Update `src/hydra/dashboard/routes/sse.py`** (extend the 06-01 stub):

    Enhance the cycle-status SSE endpoint to include more data:
    - `fill_count` from FillJournal (handle missing DB)
    - `agent_state` from get_state()
    - `timestamp` ISO 8601 UTC
    - Keep the 60-second interval

    All routes must close database connections after use (use try/finally or context manager pattern).
  </action>
  <verify>
    Run `cd /Users/tristanfarmer/Documents/HYDRA && uv run python -c "from hydra.dashboard.routes.pages import router; print('Page routes:', [r.path for r in router.routes])"` to verify all 5 page routes are registered.
  </verify>
  <done>
    5 page routes (/, /fills, /agent, /drift, /system) serve Jinja2 templates with data from FillJournal, ExperimentJournal, and agent state. 3 API endpoints provide htmx fragment updates. SSE streams enriched cycle status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create all 5 Jinja2 page templates with htmx auto-refresh</name>
  <files>
    src/hydra/dashboard/templates/index.html
    src/hydra/dashboard/templates/fills.html
    src/hydra/dashboard/templates/agent.html
    src/hydra/dashboard/templates/drift.html
    src/hydra/dashboard/templates/system.html
  </files>
  <action>
    All templates extend `base.html` and use `{% block title %}` and `{% block content %}`.

    **1. `index.html` (Overview)**
    - Header: "HYDRA Overview"
    - Three cards in a row:
      - Fill Count card: `{{ fill_count }}` total fills. Use `hx-get="/api/fills/recent" hx-trigger="every 60s" hx-swap="innerHTML"` on a div below to auto-refresh recent fills.
      - Agent State card: Badge showing `{{ agent_state }}` (green for "running", yellow for "paused"). Use `hx-get="/api/agent/state" hx-trigger="every 60s" hx-swap="innerHTML"`.
      - SSE Status card: `<div hx-ext="sse" sse-connect="/api/sse/cycle-status" sse-swap="cycle_update">Connecting...</div>` for live updates.
    - Recent activity section: table showing last 3 fills (timestamp, symbol, direction, slippage).

    **2. `fills.html` (Fill Journal)**
    - Header: "Fill Journal ({{ fill_count }} fills)"
    - If `reconciliation` is not None, show a summary card:
      - Bias: `{{ reconciliation.bias|round(4) }}`
      - RMSE: `{{ reconciliation.rmse|round(4) }}`
      - Correlation: `{{ reconciliation.correlation|round(4) }}`
      - Pessimism multiplier: `{{ reconciliation.pessimism_multiplier|round(2) }}`
    - Table with columns: Time, Symbol, Dir, Contracts, Order Price, Fill Price, Predicted Slip, Actual Slip, Latency(ms).
    - Loop over `fills` with `{% for fill in fills %}`. Use `{{ fill.timestamp[:19] }}` for readable timestamps.
    - Direction display: "BUY" if `fill.direction == 1` else "SELL". Color green/red.
    - `hx-get="/fills" hx-trigger="every 60s" hx-select="#fills-table" hx-target="#fills-table" hx-swap="outerHTML"` on the table wrapper for auto-refresh.

    **3. `agent.html` (Agent Status)**
    - Header: "Agent Loop"
    - Agent state card: `{{ agent_state }}` with color badge.
    - Experiment count: `{{ experiment_count }} experiments logged`
    - Experiment history table: ID, Timestamp, Hypothesis, Mutation Type, Outcome.
    - Loop over `experiments`. Access fields: `experiment.id`, `experiment.created_at`, `experiment.hypothesis`, `experiment.mutation_type`, `experiment.promotion_decision`. Note: ExperimentRecord has no `fitness_score` field -- use `experiment.promotion_decision` for the outcome column ("promoted" / "rejected" / "pending"). If richer metrics are needed, access `experiment.results` dict (JSON with evaluation metrics like Sharpe, drawdown, etc.).
    - Handle empty experiments list: "No experiments recorded yet."

    **4. `drift.html` (Drift Monitoring)**
    - Header: "Drift Monitoring"
    - Information card explaining: "Drift detection runs as part of the daily agent cycle. The following metrics are monitored:"
    - Two sections:
      - **Performance Drift**: Cards for Sharpe Ratio, Max Drawdown, Hit Rate, Calibration (Brier Score). Each shows the metric name, threshold, and detection method.
      - **Feature Drift**: Cards for PSI (Population Stability Index), KS Test, ADWIN (Adaptive Windowing), CUSUM (Cumulative Sum). Each shows the method, threshold, and what it detects.
    - Footer note: "Run `hydra diagnose` via CLI for a real-time drift report."

    **5. `system.html` (System Health)**
    - Header: "System Health"
    - Status cards:
      - Agent State: `{{ agent_state }}`
      - Fill Journal: `{{ db_status.fill_journal }}` (ok/unavailable)
      - Experiment Journal: `{{ db_status.experiment_journal }}` (ok/unavailable)
    - Reconciliation section (if data exists):
      - Show full reconciliation metrics in a table.
    - Configuration notes:
      - "Dashboard: read-only monitoring (control via CLI)"
      - "IB Gateway: configure via docker-compose.yml"
      - "Agent: pause/resume via `hydra pause` / `hydra run`"
    - `hx-get="/api/system/status" hx-trigger="every 60s"` for auto-refresh on status cards.

    **CSS class usage across templates:**
    - `.card` for metric cards
    - `.status-ok`, `.status-warn`, `.status-alert` for colored badges
    - Use `<table>` elements with basic styling from base CSS
    - Navigation active state: add `class="active"` to the current page's nav link (pass `active_page` from each route)
  </action>
  <verify>
    Run `cd /Users/tristanfarmer/Documents/HYDRA && uv run python -c "
from hydra.dashboard.app import create_app
from pathlib import Path
import tempfile
app = create_app(data_dir=tempfile.mkdtemp())
# Verify all templates exist and can be loaded
templates = app.state.templates
for name in ['index.html', 'fills.html', 'agent.html', 'drift.html', 'system.html']:
    env = templates.env
    t = env.get_template(name)
    print(f'{name}: OK')
print('All templates loadable')
"` to verify templates parse without Jinja2 syntax errors.
  </verify>
  <done>
    5 Jinja2 templates render all dashboard pages with data from existing HYDRA modules. htmx auto-refresh on 60-second intervals keeps pages current. SSE connection on overview page provides live cycle updates. All templates extend base.html with consistent navigation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate PaperTradingRunner as FastAPI lifespan event in app.py</name>
  <files>
    src/hydra/dashboard/app.py
  </files>
  <action>
    Update `src/hydra/dashboard/app.py` to add a FastAPI lifespan context manager that optionally starts the PaperTradingRunner alongside the dashboard.

    **Add a `start_runner: bool` parameter to `create_app`:**

    ```python
    from contextlib import asynccontextmanager

    @asynccontextmanager
    async def _lifespan(app: FastAPI):
        """FastAPI lifespan: start/stop PaperTradingRunner if enabled."""
        if getattr(app.state, "start_runner", False):
            from hydra.execution.runner import PaperTradingRunner
            # Build runner from app.state.data_dir using the same pattern as CLI
            # Import all dependencies, construct runner, call await runner.start()
            runner = _build_runner(app.state.data_dir)
            await runner.start()
            app.state.runner = runner
            logger.info("paper_trading_runner_started_via_lifespan")
        yield
        # Shutdown: stop scheduler if runner was started
        if hasattr(app.state, "runner") and app.state.runner is not None:
            if app.state.runner._scheduler is not None:
                app.state.runner._scheduler.shutdown(wait=False)
            logger.info("paper_trading_runner_stopped")

    def create_app(data_dir: str | None = None, start_runner: bool = False) -> FastAPI:
        ...
        app = FastAPI(title="HYDRA Dashboard", ..., lifespan=_lifespan)
        app.state.start_runner = start_runner
        ...
    ```

    **Add a `_build_runner(data_dir: Path) -> PaperTradingRunner` helper** that constructs the runner with all its dependencies from the data directory. This mirrors the construction logic that would otherwise live in CLI. The helper:
    1. Opens FillJournal at `data_dir / "fill_journal.db"`
    2. Opens ExperimentJournal at `data_dir / "experiment_journal.db"`
    3. Creates BrokerGateway from `IB_GATEWAY_HOST` and `IB_GATEWAY_PORT` env vars (default `127.0.0.1:4002`)
    4. Creates RiskGate with default config
    5. Creates OrderManager wrapping the broker
    6. Creates AgentLoop with the experiment journal
    7. Creates BaselineModel and SlippageReconciler
    8. Returns `PaperTradingRunner(broker, risk_gate, order_manager, fill_journal, agent_loop, model, reconciler)`

    **Key design decisions:**
    - `start_runner=False` by default -- tests and `hydra serve` for dashboard-only mode use the default. Docker CMD sets it to True.
    - The Docker CMD in 06-02's Dockerfile should be updated to pass `start_runner=True`. However, since 06-02 is in wave 1 and 06-03 is wave 2, the executor for 06-04 (or a future gap closure) can update the Dockerfile CMD. For now, document that the Docker production CMD should invoke: `uv run uvicorn "hydra.dashboard.app:create_app" --host 0.0.0.0 --port 8080 --factory` and the `create_app` factory should read `HYDRA_START_RUNNER=true` from environment variable when `start_runner` parameter is not explicitly passed.
    - Add env var check in `create_app`: `if start_runner is False: start_runner = os.environ.get("HYDRA_START_RUNNER", "").lower() == "true"`. This way Docker compose can set `HYDRA_START_RUNNER=true` in environment without changing the CMD.
    - Runner construction failures should be caught and logged (dashboard should still start even if runner can't connect to IB Gateway yet -- the runner's APScheduler will retry on the next cycle).

    Reference: 06-RESEARCH.md line 421 recommends the FastAPI lifespan context manager pattern. Both runner (APScheduler) and uvicorn share the same asyncio event loop.
  </action>
  <verify>
    Run `cd /Users/tristanfarmer/Documents/HYDRA && uv run python -c "
from hydra.dashboard.app import create_app
import tempfile
# Test default: no runner
app = create_app(data_dir=tempfile.mkdtemp(), start_runner=False)
assert app.state.start_runner == False
print('start_runner=False: OK')
# Test that lifespan is set
assert app.router.lifespan_context is not None
print('Lifespan context set: OK')
"` to verify the parameter and lifespan are wired.
  </verify>
  <done>
    FastAPI app has a lifespan context manager that starts PaperTradingRunner when `start_runner=True` or `HYDRA_START_RUNNER=true` env var is set. Default is False (dashboard-only mode for tests and CLI). Docker container activates the runner via environment variable, ensuring the full paper trading stack runs in a single process alongside the dashboard.
  </done>
</task>

</tasks>

<verification>
1. All 5 page routes return 200 with HTML content when accessed.
2. htmx polling endpoints (`/api/fills/recent`, `/api/agent/state`, `/api/system/status`) return valid HTML fragments or JSON.
3. SSE endpoint at `/api/sse/cycle-status` streams events.
4. Templates render correctly with empty data (no crashes when no fills or experiments exist).
5. All 547+ existing tests still pass.
6. `create_app(start_runner=False)` creates app without starting runner; lifespan context is set.
7. `HYDRA_START_RUNNER=true` env var activates runner in lifespan.
</verification>

<success_criteria>
- Overview page shows fill count, agent state, recent activity, and SSE live updates
- Fills page shows fill table with slippage data and reconciliation summary
- Agent page shows experiment journal history and agent state
- Drift page describes monitored metrics with detection thresholds
- System page shows database accessibility, agent state, and reconciliation stats
- All pages auto-refresh via htmx every 60 seconds
- Dashboard handles missing databases gracefully (shows "No data" instead of crashing)
- PaperTradingRunner starts as FastAPI lifespan event when `start_runner=True` or `HYDRA_START_RUNNER=true` env var is set
- Docker container runs both dashboard and runner in a single process (SQLite WAL safe)
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard-monitoring-for-paper-trading-and-full-lightweight-containerisation/06-03-SUMMARY.md`
</output>
