---
phase: 05-execution-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hydra/execution/__init__.py
  - src/hydra/execution/broker.py
  - src/hydra/execution/risk_gate.py
  - tests/test_broker.py
  - tests/test_risk_gate.py
  - pyproject.toml
autonomous: true
requirements:
  - EXEC-01
  - EXEC-04

must_haves:
  truths:
    - "BrokerGateway wraps ib_async.IB with connect/disconnect/reconnect and order submission"
    - "RiskGate enforces all circuit breaker checks before any order reaches the broker -- no bypass path exists"
    - "Paper trading port 4002 is the default; live port 4001 requires explicit opt-in"
    - "Client ID allocation is enforced: 1=trading, 2=diagnostic, 3=CLI"
  artifacts:
    - path: "src/hydra/execution/__init__.py"
      provides: "Public API for execution module"
    - path: "src/hydra/execution/broker.py"
      provides: "BrokerGateway class wrapping ib_async"
      contains: "class BrokerGateway"
    - path: "src/hydra/execution/risk_gate.py"
      provides: "RiskGate mandatory pre-trade middleware"
      contains: "class RiskGate"
    - path: "tests/test_broker.py"
      provides: "BrokerGateway unit tests"
    - path: "tests/test_risk_gate.py"
      provides: "RiskGate unit tests"
  key_links:
    - from: "src/hydra/execution/risk_gate.py"
      to: "src/hydra/risk/circuit_breakers.py"
      via: "CircuitBreakerManager.check_trade()"
      pattern: "self._breakers\\.check_trade"
    - from: "src/hydra/execution/risk_gate.py"
      to: "src/hydra/execution/broker.py"
      via: "BrokerGateway.submit_order()"
      pattern: "self._broker\\.submit_order"
---

<objective>
Create the broker abstraction layer and risk gate middleware that form the foundation of the execution pipeline.

Purpose: BrokerGateway wraps ib_async into a clean async interface with reconnection handling. RiskGate sits between the order manager and broker, enforcing all circuit breaker checks as mandatory middleware (EXEC-04). Together they ensure paper and live trading use the exact same code path (EXEC-01), differing only in connection port.

Output: Two production modules with tests, ib_async added as dependency.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-execution-hardening/05-RESEARCH.md
@src/hydra/risk/circuit_breakers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: BrokerGateway -- ib_async wrapper with connection management</name>
  <files>
    src/hydra/execution/__init__.py
    src/hydra/execution/broker.py
    tests/test_broker.py
    pyproject.toml
  </files>
  <action>
    1. Add `ib_async` to pyproject.toml dependencies via `uv add ib_async`.

    2. Create `src/hydra/execution/__init__.py` -- export BrokerGateway and RiskGate (RiskGate added in Task 2).

    3. Create `src/hydra/execution/broker.py` with class `BrokerGateway`:

    Constructor params:
    - `host: str = "127.0.0.1"`
    - `port: int = 4002` (PAPER default -- 4002 for Gateway, 7497 for TWS)
    - `client_id: int = 1` (1=trading, 2=diagnostic, 3=CLI)
    - `readonly: bool = False`

    Key safety: Include a class-level constant `LIVE_PORTS = {4001, 7496}` and a `PAPER_PORTS = {4002, 7497}`. On init, log clearly whether in paper or live mode based on port. Add a property `is_paper` that returns `self._port in self.PAPER_PORTS`.

    Methods:
    - `async connect() -> None`: Call `self.ib.connectAsync(host, port, clientId=client_id, readonly=readonly)`. Register `disconnectedEvent` handler for auto-reconnect. Log connection with structlog including port, client_id, and paper/live mode.
    - `async disconnect() -> None`: Call `self.ib.disconnect()`.
    - `async reconnect() -> None`: Exponential backoff reconnection loop (1s, 2s, 4s, 8s, max 30s). Max 10 attempts before raising `ConnectionError`. Log each attempt.
    - `async submit_order(contract, order) -> Trade`: Thin wrapper around `self.ib.placeOrder(contract, order)`. Returns the Trade object.
    - `async cancel_order(trade) -> None`: Cancel via `self.ib.cancelOrder(trade.order)`.
    - `async qualify_contract(contract) -> Contract`: Wrapper around `self.ib.qualifyContractsAsync(contract)`. Returns the qualified contract.
    - `async get_positions() -> list`: Returns `self.ib.positions()`.
    - `async get_account_summary() -> list`: Returns `self.ib.accountSummary()`.
    - `def is_connected() -> bool`: Returns `self.ib.isConnected()`.
    - `async resync_state() -> None`: After reconnection, calls `self.ib.reqOpenOrders()` and `self.ib.reqPositions()` to resynchronize (per Pitfall 6 from research).

    Private:
    - `async _on_disconnect() -> None`: Auto-reconnect handler registered on `disconnectedEvent`. Calls `reconnect()` then `resync_state()`.

    Use `structlog.get_logger()` for all logging.

    4. Create `tests/test_broker.py`:
    - Test init defaults: port 4002, client_id 1, is_paper=True.
    - Test is_paper property for all 4 port values (4001, 4002, 7496, 7497).
    - Test that BrokerGateway can be instantiated without a running IB Gateway (no actual connection in unit tests).
    - Mock ib_async.IB to test submit_order delegates to placeOrder, cancel_order delegates to cancelOrder.
    - Test reconnect gives up after max_retries and raises ConnectionError.

    Do NOT test actual IB connectivity -- that is for the integration checkpoint in Plan 05-05.
  </action>
  <verify>
    `cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/test_broker.py -v` passes all tests.
    `python -c "from hydra.execution.broker import BrokerGateway; g = BrokerGateway(); print(g.is_paper)"` prints True.
  </verify>
  <done>
    BrokerGateway class exists with async connect/disconnect/reconnect/submit_order/cancel_order/qualify_contract methods. Default port is paper (4002). is_paper property distinguishes paper from live. Unit tests pass with mocked IB. ib_async is a project dependency.
  </done>
</task>

<task type="auto">
  <name>Task 2: RiskGate -- mandatory pre-trade circuit breaker middleware</name>
  <files>
    src/hydra/execution/risk_gate.py
    src/hydra/execution/__init__.py
    tests/test_risk_gate.py
  </files>
  <action>
    1. Create `src/hydra/execution/risk_gate.py` with class `RiskGate`:

    The key architectural constraint: there is NO code path from OrderManager to BrokerGateway that bypasses RiskGate. RiskGate owns the only reference to the broker's submit method.

    Constructor params:
    - `broker: BrokerGateway` -- the underlying broker
    - `breakers: CircuitBreakerManager` -- from `hydra.risk.circuit_breakers`

    Methods:
    - `async submit(self, contract, order, daily_pnl: float, peak_equity: float, current_equity: float, position_value: float, trade_loss: float) -> Trade | None`:
      1. Call `self._breakers.check_trade(daily_pnl, peak_equity, current_equity, position_value, trade_loss)`.
      2. If `allowed` is False, log warning with `structlog` including `triggered` breaker names, return `None`.
      3. If allowed, call `await self._broker.submit_order(contract, order)` and return the Trade.
      Log every submission attempt and outcome (allowed/blocked) with structlog.

    - `async cancel(self, trade) -> None`: Delegate to `self._broker.cancel_order(trade)`.

    - `@property def broker(self) -> BrokerGateway`: Read-only access to the broker for non-order operations (positions, account summary). This does NOT expose submit_order -- callers must go through RiskGate.submit().

    Important: The RiskGate does NOT expose a raw `submit_order` passthrough. The only way to submit an order is through `RiskGate.submit()` which includes the risk check. Document this in the class docstring.

    2. Update `src/hydra/execution/__init__.py` to export `RiskGate`.

    3. Create `tests/test_risk_gate.py`:
    - Test that when all breakers are ACTIVE and values are within thresholds, submit delegates to broker and returns a Trade.
    - Test that when a breaker trips (e.g., daily_pnl = -0.05 with threshold -0.02), submit returns None and does NOT call broker.submit_order.
    - Test that multiple simultaneous breaker triggers are all logged.
    - Test the cancel method delegates to broker.cancel_order.
    - Test that RiskGate.broker property returns the broker but does not expose submit_order bypass.

    Use `unittest.mock.AsyncMock` for BrokerGateway mock. Use a real `CircuitBreakerManager` with default thresholds.
  </action>
  <verify>
    `cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/test_risk_gate.py -v` passes all tests.
    `python -c "from hydra.execution import BrokerGateway, RiskGate"` imports without error.
  </verify>
  <done>
    RiskGate class exists as mandatory middleware between OrderManager and BrokerGateway. Every order submission goes through circuit breaker checks. No bypass path exists. Tests verify both allow and block scenarios. Execution module __init__.py exports both BrokerGateway and RiskGate.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_broker.py tests/test_risk_gate.py -v` -- all tests pass
- `python -c "from hydra.execution import BrokerGateway, RiskGate; from hydra.risk.circuit_breakers import CircuitBreakerManager; b = BrokerGateway(); r = RiskGate(b, CircuitBreakerManager()); print('OK')"` prints OK
- Verify no direct broker access without RiskGate in the public API
</verification>

<success_criteria>
- BrokerGateway wraps ib_async with paper-default connection, reconnection, and order lifecycle methods
- RiskGate enforces circuit breaker checks on every order submission with no bypass
- Both classes use structlog for all operational logging
- All unit tests pass with mocked IB connection
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-hardening/05-01-SUMMARY.md`
</output>
