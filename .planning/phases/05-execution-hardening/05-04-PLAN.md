---
phase: 05-execution-hardening
plan: 04
type: execute
wave: 3
depends_on:
  - 05-02
  - 05-03
files_modified:
  - src/hydra/execution/runner.py
  - src/hydra/cli/app.py
  - src/hydra/cli/formatters.py
  - tests/test_runner.py
autonomous: true
requirements:
  - EXEC-01
  - EXEC-05

must_haves:
  truths:
    - "PaperTradingRunner orchestrates the daily cycle: connect, get market data, run agent loop, execute orders, log fills, disconnect"
    - "The execution path (OrderManager -> RiskGate -> BrokerGateway) is identical for paper and live"
    - "CLI has paper-trade command to start/stop paper trading and fill-report command to view slippage reconciliation"
    - "Agent loop is invoked on a schedule via APScheduler for the 4+ week stability period"
    - "Self-healing cycle is possible: agent detects drift, diagnoses, proposes fix, tests, promotes -- all while paper trading continues"
  artifacts:
    - path: "src/hydra/execution/runner.py"
      provides: "Paper trading runner orchestrating daily cycle"
      contains: "class PaperTradingRunner"
    - path: "src/hydra/cli/app.py"
      provides: "Extended CLI with paper-trade and fill-report commands"
      contains: "def paper_trade"
    - path: "tests/test_runner.py"
      provides: "Runner unit tests"
  key_links:
    - from: "src/hydra/execution/runner.py"
      to: "src/hydra/agent/loop.py"
      via: "AgentLoop.run_cycle()"
      pattern: "self._agent_loop\\.run_cycle"
    - from: "src/hydra/execution/runner.py"
      to: "src/hydra/model/baseline.py"
      via: "BaselineModel.predict()"
      pattern: "self._model\\.predict"
    - from: "src/hydra/execution/runner.py"
      to: "src/hydra/execution/order_manager.py"
      via: "OrderManager.route_order()"
      pattern: "self._order_manager\\.route_order"
    - from: "src/hydra/execution/runner.py"
      to: "src/hydra/execution/fill_journal.py"
      via: "FillJournal.log_fill()"
      pattern: "self._fill_journal\\.log_fill"
    - from: "src/hydra/cli/app.py"
      to: "src/hydra/execution/runner.py"
      via: "PaperTradingRunner"
      pattern: "PaperTradingRunner"
---

<objective>
Build the paper trading runner that orchestrates the daily cycle and extend the CLI with paper trading commands.

Purpose: EXEC-01 requires the paper trading pipeline to use the same execution path as live. EXEC-05 requires 4+ weeks of stable paper trading with a self-healing cycle. PaperTradingRunner ties everything together: it connects to IB, runs the agent loop on a schedule, executes orders through the full risk-checked pipeline, logs fills, and provides CLI commands for operator control.

Output: PaperTradingRunner, APScheduler integration, and CLI extensions for paper-trade and fill-report.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-execution-hardening/05-RESEARCH.md
@.planning/phases/05-execution-hardening/05-01-SUMMARY.md
@.planning/phases/05-execution-hardening/05-02-SUMMARY.md
@.planning/phases/05-execution-hardening/05-03-SUMMARY.md
@src/hydra/agent/loop.py
@src/hydra/model/baseline.py
@src/hydra/cli/app.py
@src/hydra/cli/formatters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PaperTradingRunner -- daily cycle orchestrator with APScheduler</name>
  <files>
    src/hydra/execution/runner.py
    src/hydra/execution/__init__.py
    tests/test_runner.py
  </files>
  <action>
    1. Create `src/hydra/execution/runner.py` with class `PaperTradingRunner`:

    Constructor params (all injected):
    - `broker: BrokerGateway`
    - `risk_gate: RiskGate`
    - `order_manager: OrderManager`
    - `fill_journal: FillJournal`
    - `agent_loop: AgentLoop` (from `hydra.agent.loop`)
    - `model: BaselineModel` (from `hydra.model.baseline`) -- the trading signal source
    - `reconciler: SlippageReconciler`
    - `config: dict | None = None` -- runtime configuration

    IMPORTANT separation of concerns: AgentLoop handles the self-healing cycle (observe drift, diagnose, hypothesize, experiment, evaluate/promote). BaselineModel.predict() is the actual trading signal source. These are independent: the agent loop maintains model quality over time, while the model produces the daily trading signal. The runner orchestrates both.

    Config dict keys (with defaults):
    - `schedule_hour: int = 14` -- hour to run daily cycle (14:00 = 2 PM, after 1:15 PM CT pit close)
    - `schedule_minute: int = 0`
    - `schedule_timezone: str = "US/Central"`
    - `trading_mode: str = "paper"` -- "paper" or "live"

    Methods:

    - `async start(self) -> None`:
      1. Validate trading_mode. If "live", require explicit `HYDRA_LIVE_CONFIRMED=true` env var, otherwise raise ValueError.
      2. Connect broker via `await self._broker.connect()`.
      3. Log startup with structlog: mode (paper/live), port, schedule.
      4. Set up APScheduler `AsyncIOScheduler` with a CronTrigger for `run_daily_cycle` at the configured time.
      5. Start the scheduler.

    - `async stop(self) -> None`:
      1. Shut down scheduler.
      2. Disconnect broker.
      3. Close fill journal.
      4. Log shutdown.

    - `async run_daily_cycle(self) -> dict`:
      This is the core paper trading loop for one day:
      1. **Check connection**: If not connected, attempt reconnect. Log and skip if reconnect fails.
      2. **Get account state**: Call broker.get_account_summary() and broker.get_positions() for risk gate params (daily_pnl, current_equity, peak_equity, position_value).
      3. **Run agent loop (self-healing)**: Call `self._agent_loop.run_cycle(...)` with the latest data. The agent loop handles observe/diagnose/hypothesize/experiment/evaluate internally. Its output (`AgentCycleResult`) contains drift/healing state (promoted, rolled_back, diagnosis), NOT trading predictions. Log the agent cycle outcome for monitoring.
      4. **Generate trading signal**: Call `self._model.predict(features)` where features are the latest market data (assembled from account state / market data in step 2). This returns binary direction predictions. Convert to direction ("BUY"/"SELL") and position size. If model is not fitted or returns no signal, skip order execution for this cycle and log the skip.
      5. **Execute signal**: Use `self._order_manager.route_order(contract, direction, n_contracts, adv, mid_price, daily_pnl, peak_equity, current_equity, position_value, trade_loss)` to execute the signal through the risk-checked pipeline.
      6. **Log fills**: After order execution, iterate over trades' fills and log each to `self._fill_journal.log_fill(...)`. Compute predicted slippage via `estimate_slippage()` from `hydra.risk.slippage` for each fill. Compute actual slippage as `abs(fill_price - order_price)`.
      7. **Return summary**: Return a dict with cycle_time, agent_result, signal (direction + size or None), n_fills, n_orders_blocked.

      KEY: AgentLoop and BaselineModel serve different roles. AgentLoop is the self-healing cycle that maintains model quality over time (detect drift -> retrain -> evaluate). BaselineModel.predict() is the signal source that produces today's trading decision. Both are called each cycle, but independently.

    - `async run_reconciliation(self, symbol: str | None = None) -> ReconciliationReport | None`:
      Delegate to `self._reconciler.reconcile(symbol)`.

    Important: Use `asyncio.to_thread()` for any CPU-bound work (model training in agent loop happens in subprocess via ExperimentRunner, so the event loop stays responsive).

    2. Update `src/hydra/execution/__init__.py` to export PaperTradingRunner.

    3. Create `tests/test_runner.py`:
    - Test start validates trading_mode and rejects "live" without env var.
    - Test run_daily_cycle calls broker.connect check, agent_loop.run_cycle, model.predict, and order_manager.route_order in correct order.
    - Test run_daily_cycle skips order execution when model.predict returns no signal (model not fitted).
    - Test that fills are logged to fill_journal after order execution.
    - Test stop shuts down scheduler and disconnects broker.
    - Test run_reconciliation delegates to reconciler.
    - Mock all dependencies (broker, risk_gate, order_manager, fill_journal, agent_loop, model, reconciler) with AsyncMock/MagicMock.
    - Do NOT test actual IB connectivity or scheduling -- those are for the integration checkpoint.
  </action>
  <verify>
    `cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/test_runner.py -v` passes all tests.
    `python -c "from hydra.execution import PaperTradingRunner"` imports without error.
  </verify>
  <done>
    PaperTradingRunner orchestrates the daily cycle: connect, run agent loop, execute orders through full risk pipeline, log fills, track slippage. APScheduler integration for daily scheduling. Live mode requires explicit confirmation. All dependencies injected for testability.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI extensions -- paper-trade and fill-report commands</name>
  <files>
    src/hydra/cli/app.py
    src/hydra/cli/formatters.py
  </files>
  <action>
    1. Add two new commands to `src/hydra/cli/app.py`:

    **`paper_trade` command:**
    ```
    @app.command(name="paper-trade")
    def paper_trade(
        action: str = typer.Argument(help="start or stop"),
        port: int = typer.Option(4002, help="IB Gateway port (4002=paper, 4001=live)"),
        client_id: int = typer.Option(1, help="IB client ID (1=trading)"),
        journal_path: Optional[str] = typer.Option(None, help="Fill journal SQLite path"),
        schedule_hour: int = typer.Option(14, help="Daily cycle hour (24h, US/Central)"),
        schedule_minute: int = typer.Option(0, help="Daily cycle minute"),
    ) -> None:
    ```
    For "start":
    - Display a Rich panel confirming paper/live mode based on port.
    - If port is in LIVE_PORTS (4001, 7496), show RED warning and require `--yes-i-mean-live` flag (typer.Option, default False).
    - Log the configuration and print startup message.
    - NOTE: Actual async runner startup would need `asyncio.run()` -- for the CLI command, display the configuration and status. The actual long-running process will use `python -m hydra.execution.runner` entry point.

    For "stop":
    - Set agent state to PAUSED (reusing existing state mechanism).
    - Print confirmation.

    **`fill_report` command:**
    ```
    @app.command(name="fill-report")
    def fill_report(
        journal_path: Optional[str] = typer.Option(None, help="Fill journal SQLite path"),
        symbol: Optional[str] = typer.Option(None, help="Filter by symbol"),
        since: Optional[str] = typer.Option(None, help="Filter fills since date (ISO 8601)"),
        limit: int = typer.Option(20, help="Max fills to display"),
    ) -> None:
    ```
    - Open FillJournal from journal_path (default: `~/.hydra/fill_journal.db`).
    - If `--reconcile` flag: run SlippageReconciler and display ReconciliationReport.
    - Otherwise: query recent fills and display via Rich table.

    2. Add to `src/hydra/cli/formatters.py`:

    - `format_fill_table(fills: list[FillRecord]) -> Table`:
      Rich table with columns: Time, Symbol, Dir, Qty, Order Price, Fill Price, Pred Slip, Actual Slip, Latency.
      Direction shows "BUY" in green or "SELL" in red.

    - `format_reconciliation_report(report: ReconciliationReport) -> Panel`:
      Rich panel showing: N Fills, Mean Predicted, Mean Actual, Bias, RMSE, Correlation, Pessimism Multiplier.
      Color-code bias: green if < 0.1, yellow if < 0.5, red if >= 0.5.
      Show recommendation: if pessimism_multiplier > 1.5, warn "Paper fills are significantly optimistic".

    3. Add `--reconcile` boolean option to fill_report command to switch between fill list and reconciliation report.

    Do NOT modify the existing 6 commands (status, diagnose, rollback, pause, run, journal). Only ADD new commands.
  </action>
  <verify>
    `cd /Users/tristanfarmer/Documents/HYDRA && python -c "from hydra.cli.app import app; print([c.name for c in app.registered_commands])"` shows paper-trade and fill-report in the list.
    `python -c "from hydra.cli.formatters import format_fill_table, format_reconciliation_report"` imports without error.
  </verify>
  <done>
    CLI has paper-trade command (start/stop with port safety) and fill-report command (fill list + reconciliation). Rich-formatted tables for fills and reconciliation report. Live port requires explicit confirmation. Existing commands untouched.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_runner.py -v` -- all tests pass
- `python -c "from hydra.execution import PaperTradingRunner; from hydra.cli.app import app; print('OK')"` prints OK
- CLI help shows paper-trade and fill-report commands: `python -m hydra.cli.app --help`
- Verify PaperTradingRunner calls agent_loop.run_cycle and order_manager.route_order in the daily cycle
</verification>

<success_criteria>
- PaperTradingRunner orchestrates complete daily cycle with all execution modules
- APScheduler schedules daily cycles at configurable time
- Live trading requires explicit env var confirmation
- CLI paper-trade command shows configuration and controls runner
- CLI fill-report command displays fills and reconciliation with Rich formatting
- All unit tests pass with mocked dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-hardening/05-04-SUMMARY.md`
</output>
