---
phase: 05-execution-hardening
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/hydra/execution/fill_journal.py
  - src/hydra/execution/reconciler.py
  - src/hydra/execution/__init__.py
  - tests/test_fill_journal.py
  - tests/test_reconciler.py
autonomous: true
requirements:
  - EXEC-02

must_haves:
  truths:
    - "Every fill from IB is logged with timestamp, prices, predicted slippage, actual slippage, and market conditions"
    - "SlippageReconciler compares predicted vs actual slippage distributions and produces bias/RMSE metrics"
    - "FillJournal uses SQLite with WAL mode, consistent with ExperimentJournal pattern"
    - "Predicted slippage comes from the existing estimate_slippage() function -- not reimplemented"
  artifacts:
    - path: "src/hydra/execution/fill_journal.py"
      provides: "SQLite fill logging for slippage tracking"
      contains: "class FillJournal"
    - path: "src/hydra/execution/reconciler.py"
      provides: "Actual vs predicted slippage comparison"
      contains: "class SlippageReconciler"
    - path: "tests/test_fill_journal.py"
      provides: "Fill journal unit tests"
    - path: "tests/test_reconciler.py"
      provides: "Reconciler unit tests"
  key_links:
    - from: "src/hydra/execution/reconciler.py"
      to: "src/hydra/risk/slippage.py"
      via: "estimate_slippage()"
      pattern: "estimate_slippage"
    - from: "src/hydra/execution/fill_journal.py"
      to: "sqlite3"
      via: "SQLite WAL mode"
      pattern: "PRAGMA journal_mode=WAL"
---

<objective>
Build the fill logging and slippage validation infrastructure for paper trading.

Purpose: EXEC-02 requires all paper trading fills to be logged with timestamps and actual slippage, and the simulated slippage model to be validated against real fill data. FillJournal captures every fill event. SlippageReconciler compares predicted (from `estimate_slippage()`) vs actual slippage to quantify how optimistic paper fills are.

Output: FillJournal (SQLite) and SlippageReconciler with statistical comparison metrics.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-execution-hardening/05-RESEARCH.md
@src/hydra/risk/slippage.py
@src/hydra/sandbox/journal.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: FillJournal -- SQLite fill logging with slippage tracking</name>
  <files>
    src/hydra/execution/fill_journal.py
    tests/test_fill_journal.py
  </files>
  <action>
    1. Create `src/hydra/execution/fill_journal.py`:

    Define `FillRecord` dataclass:
    ```
    @dataclass
    class FillRecord:
        timestamp: str           # ISO 8601 UTC
        symbol: str
        direction: int           # +1 long, -1 short
        n_contracts: int
        order_price: float       # mid-price at order entry
        fill_price: float        # actual fill price from IB
        predicted_slippage: float  # from estimate_slippage()
        actual_slippage: float   # abs(fill_price - order_price) per contract
        volume_at_fill: float    # market volume at time of fill
        spread_at_fill: float    # bid-ask spread at time of fill
        fill_latency_ms: float   # time from order submission to fill
        order_id: int | None = None  # IB order ID
        id: int | None = None    # auto-assigned by DB
    ```

    Define `FillJournal` class (same SQLite WAL pattern as ExperimentJournal):

    Constructor: `__init__(self, db_path: str | Path)`.
    - Connect to SQLite with WAL mode.
    - Create `fills` table with columns matching FillRecord fields.
    - Create indexes on `timestamp`, `symbol`.

    Methods:
    - `log_fill(self, record: FillRecord) -> int`: Insert a fill record. Return the auto-generated ID.
    - `get_fills(self, symbol: str | None = None, since: str | None = None, until: str | None = None, limit: int = 1000) -> list[FillRecord]`: Query fills with AND-combined filters. Order by timestamp DESC.
    - `get_slippage_pairs(self, symbol: str | None = None, since: str | None = None) -> list[tuple[float, float]]`: Return list of (predicted_slippage, actual_slippage) pairs for reconciliation.
    - `count(self) -> int`: Total fill count.
    - `close(self) -> None`: Close DB connection.

    Use structlog for logging.

    2. Create `tests/test_fill_journal.py`:
    - Test log_fill inserts a record and returns an auto-incremented ID.
    - Test get_fills returns records filtered by symbol.
    - Test get_fills returns records filtered by date range.
    - Test get_slippage_pairs returns (predicted, actual) tuples.
    - Test count returns correct count after multiple inserts.
    - Test empty journal returns empty lists.
    - Use a temp file via `tmp_path` fixture for SQLite DB.
  </action>
  <verify>
    `cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/test_fill_journal.py -v` passes all tests.
  </verify>
  <done>
    FillJournal logs every fill with timestamps, prices, predicted/actual slippage, and market conditions. SQLite with WAL mode. Query layer supports filtering by symbol and date range. Slippage pairs extractable for reconciliation.
  </done>
</task>

<task type="auto">
  <name>Task 2: SlippageReconciler -- predicted vs actual slippage comparison</name>
  <files>
    src/hydra/execution/reconciler.py
    src/hydra/execution/__init__.py
    tests/test_reconciler.py
  </files>
  <action>
    1. Create `src/hydra/execution/reconciler.py`:

    Define `ReconciliationReport` dataclass:
    ```
    @dataclass
    class ReconciliationReport:
        n_fills: int                    # number of fills analyzed
        mean_predicted: float           # mean predicted slippage
        mean_actual: float              # mean actual slippage
        bias: float                     # mean_actual - mean_predicted (positive = model underestimates)
        rmse: float                     # root mean squared error between predicted and actual
        median_predicted: float
        median_actual: float
        correlation: float              # Pearson correlation between predicted and actual
        pessimism_multiplier: float     # mean_actual / mean_predicted (how much worse reality is)
        percentile_95_actual: float     # 95th percentile of actual slippage
        percentile_95_predicted: float  # 95th percentile of predicted slippage
    ```

    Define `SlippageReconciler` class:

    Constructor: `__init__(self, fill_journal: FillJournal)`.

    Methods:
    - `reconcile(self, symbol: str | None = None, since: str | None = None) -> ReconciliationReport | None`:
      1. Call `self._journal.get_slippage_pairs(symbol, since)`.
      2. If fewer than 10 fills, return None (insufficient data).
      3. Compute all ReconciliationReport metrics using numpy:
         - `bias = np.mean(actual) - np.mean(predicted)`
         - `rmse = np.sqrt(np.mean((actual - predicted) ** 2))`
         - `correlation = np.corrcoef(predicted, actual)[0, 1]` (handle NaN if all same)
         - `pessimism_multiplier = np.mean(actual) / max(np.mean(predicted), 1e-10)`
         - Percentiles via `np.percentile(arr, 95)`
      4. Log report summary with structlog.
      5. Return ReconciliationReport.

    - `is_model_calibrated(self, max_bias: float = 0.5, min_correlation: float = 0.3) -> tuple[bool, str]`:
      Run reconcile(). If report is None, return (False, "Insufficient data"). If abs(bias) > max_bias or correlation < min_correlation, return (False, reason). Else return (True, "Model calibrated").

    2. Update `src/hydra/execution/__init__.py` to export FillJournal, FillRecord, SlippageReconciler, ReconciliationReport.

    3. Create `tests/test_reconciler.py`:
    - Test reconcile with fewer than 10 fills returns None.
    - Test reconcile with synthetic data where predicted == actual: bias should be ~0, correlation ~1.
    - Test reconcile with systematic bias: predicted=0.5, actual=1.0 for all fills. Bias should be ~0.5, pessimism_multiplier ~2.0.
    - Test is_model_calibrated returns True for well-calibrated synthetic data.
    - Test is_model_calibrated returns False with excessive bias.
    - Use a real FillJournal with tmp_path fixture. Insert synthetic FillRecords.
  </action>
  <verify>
    `cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/test_reconciler.py -v` passes all tests.
    `python -c "from hydra.execution import FillJournal, SlippageReconciler, ReconciliationReport"` imports without error.
  </verify>
  <done>
    SlippageReconciler computes bias, RMSE, correlation, and pessimism multiplier between predicted and actual slippage. is_model_calibrated provides a boolean check. Minimum 10 fills required for meaningful statistics. Tests verify with synthetic data.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_fill_journal.py tests/test_reconciler.py -v` -- all tests pass
- `python -c "from hydra.execution import FillJournal, FillRecord, SlippageReconciler, ReconciliationReport; print('OK')"` prints OK
- Verify FillJournal uses WAL mode (grep for PRAGMA journal_mode=WAL)
</verification>

<success_criteria>
- FillJournal logs fills with all required fields (timestamp, prices, predicted/actual slippage, volume, spread, latency)
- SlippageReconciler produces ReconciliationReport with bias, RMSE, correlation, pessimism multiplier
- Minimum 10 fills required for reconciliation (returns None otherwise)
- SQLite with WAL mode consistent with ExperimentJournal pattern
- All unit tests pass with synthetic data
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-hardening/05-03-SUMMARY.md`
</output>
