---
phase: 05-execution-hardening
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/hydra/execution/order_manager.py
  - src/hydra/execution/__init__.py
  - tests/test_order_manager.py
autonomous: true
requirements:
  - EXEC-03

must_haves:
  truths:
    - "Small orders (< 1% ADV) use limit-with-patience: mid-price limit, patience timeout, then step toward market"
    - "Large orders (>= 1% ADV) use custom TWAP: sliced into N time-spaced limit orders with randomized intervals"
    - "No market orders are ever submitted -- all paths produce limit orders"
    - "OrderManager routes through RiskGate, not directly to BrokerGateway"
  artifacts:
    - path: "src/hydra/execution/order_manager.py"
      provides: "Smart order routing for thin futures markets"
      contains: "class OrderManager"
    - path: "tests/test_order_manager.py"
      provides: "Order manager unit tests"
  key_links:
    - from: "src/hydra/execution/order_manager.py"
      to: "src/hydra/execution/risk_gate.py"
      via: "RiskGate.submit()"
      pattern: "self._risk_gate\\.submit"
---

<objective>
Implement smart order routing for thin commodity futures markets.

Purpose: EXEC-03 requires limit orders with patience for normal-sized orders and TWAP slicing for larger positions. Thin commodity futures (oats, lean hogs) have limited volume, so market orders would be catastrophic and IB's built-in TWAP may not handle <500 daily volume well. Custom routing gives volume-aware control.

Output: OrderManager class with limit-patience and TWAP strategies, routed through RiskGate.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-execution-hardening/05-RESEARCH.md
@.planning/phases/05-execution-hardening/05-01-SUMMARY.md
@src/hydra/execution/risk_gate.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: OrderManager with limit-patience and TWAP routing</name>
  <files>
    src/hydra/execution/order_manager.py
    tests/test_order_manager.py
  </files>
  <action>
    1. Create `src/hydra/execution/order_manager.py` with class `OrderManager`:

    Constructor params:
    - `risk_gate: RiskGate` -- all orders go through risk gate, never directly to broker
    - `patience_seconds: int = 300` -- 5 min patience window for limit orders
    - `twap_volume_threshold: float = 0.01` -- orders > 1% ADV get TWAP
    - `twap_slices: int = 5` -- number of TWAP time slices
    - `twap_jitter_pct: float = 0.20` -- randomize slice timing by +/- 20%
    - `price_step_pct: float = 0.001` -- price step toward market when patience exhausted (0.1%)

    Public methods:

    - `async route_order(self, contract, direction: str, n_contracts: int, adv: float, mid_price: float, daily_pnl: float, peak_equity: float, current_equity: float, position_value: float, trade_loss: float) -> list[Trade | None]`:
      Compute `participation_rate = n_contracts / max(adv, 1)`.
      If `participation_rate >= self.twap_volume_threshold`: call `_twap_slice(...)`.
      Else: call `_limit_with_patience(...)`.
      Returns list of Trade objects (single for limit, multiple for TWAP). None entries indicate risk-blocked orders.

    Private methods:

    - `async _limit_with_patience(self, contract, direction, n_contracts, mid_price, risk_params) -> list[Trade | None]`:
      1. Create a `LimitOrder(direction, n_contracts, mid_price)` using ib_async.
      2. Submit via `self._risk_gate.submit(contract, order, **risk_params)`.
      3. Wait up to `patience_seconds` for fill by checking `trade.orderStatus.status` in a loop with `asyncio.sleep(1)` intervals.
      4. If not filled after patience: modify order price toward market by `price_step_pct` (buy: increase price, sell: decrease price). Wait another patience_seconds / 2.
      5. If still not filled after second patience: modify to cross the spread (buy at ask, sell at bid). Wait patience_seconds / 4.
      6. Return the list with the single Trade.
      Log each stage with structlog: initial placement, patience expired, price step, spread cross.

    - `async _twap_slice(self, contract, direction, n_contracts, mid_price, risk_params) -> list[Trade | None]`:
      1. Compute `slice_size = n_contracts // self.twap_slices` and `remainder = n_contracts % self.twap_slices`.
      2. For each slice i in range(twap_slices):
         a. Compute jittered delay: `base_interval = patience_seconds / twap_slices`, then `delay = base_interval * (1 + random.uniform(-twap_jitter_pct, twap_jitter_pct))`.
         b. `await asyncio.sleep(delay)` (except for first slice).
         c. Determine slice contracts: `slice_size + (1 if i < remainder else 0)`.
         d. Submit limit order at current mid_price via `_limit_with_patience` (reusing the patience logic for each slice).
      3. Return list of all Trade objects.
      Log TWAP plan at start: total contracts, n_slices, base interval.

    - `_compute_risk_params(daily_pnl, peak_equity, current_equity, position_value, trade_loss) -> dict`: Package risk params into dict for passing to risk_gate.submit.

    Important: `direction` must be "BUY" or "SELL" string (ib_async convention). Never use "MARKET" order type -- all orders are LimitOrder.

    2. Update `src/hydra/execution/__init__.py` to export `OrderManager`.

    3. Create `tests/test_order_manager.py`:
    - Test routing decision: small order (participation_rate < threshold) goes to limit_with_patience.
    - Test routing decision: large order (participation_rate >= threshold) goes to twap_slice.
    - Test that all orders are LimitOrder type, never MarketOrder.
    - Test TWAP slicing math: 13 contracts with 5 slices = [3, 3, 3, 2, 2] or equivalent remainder distribution.
    - Test that OrderManager calls risk_gate.submit, not broker.submit_order directly.
    - Test that when risk_gate returns None (blocked), the Trade list contains None entries.

    Mock the RiskGate with AsyncMock. Mock asyncio.sleep to avoid real delays in tests. Use a mock contract and direction for all tests.
  </action>
  <verify>
    `cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/test_order_manager.py -v` passes all tests.
    `python -c "from hydra.execution import OrderManager"` imports without error.
  </verify>
  <done>
    OrderManager routes orders through RiskGate with two strategies: limit-with-patience for small orders, custom TWAP slicing for large orders. No market orders are ever submitted. TWAP uses randomized intervals for unpredictability. All tests pass with mocked dependencies.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_order_manager.py -v` -- all tests pass
- `python -c "from hydra.execution import OrderManager; print('OK')"` prints OK
- Verify no MarketOrder import or usage anywhere in order_manager.py
</verification>

<success_criteria>
- OrderManager selects limit-patience or TWAP based on participation rate
- TWAP slices orders with randomized timing intervals
- All orders route through RiskGate.submit() -- never direct to broker
- No market orders are ever created
- Unit tests verify routing logic, slicing math, and risk gate delegation
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-hardening/05-02-SUMMARY.md`
</output>
