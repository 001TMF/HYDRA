---
phase: 04-agent-core-llm-integration
plan: 05
type: execute
wave: 2
depends_on: [04-01, 04-02, 04-03, 04-04]
files_modified:
  - src/hydra/agent/loop.py
  - src/hydra/agent/__init__.py
  - tests/agent/test_loop.py
  - tests/agent/test_integration.py
autonomous: true
requirements: [AGNT-01]

must_haves:
  truths:
    - "Agent runs the full observe -> diagnose -> hypothesize -> experiment -> evaluate loop end-to-end"
    - "Each step is logged to the experiment journal with timestamps and full context"
    - "Agent loop checks autonomy permission before each step and stops if denied"
    - "Agent loop uses dedup, budget, and cooldown checks before running experiments"
    - "Agent loop falls back to rule-based at every step when LLM is unavailable (AGNT-10 integration)"
    - "Agent loop triggers rollback when HysteresisRollbackTrigger fires"
    - "Agent loop promotes candidate when PromotionEvaluator approves (3-of-5 windows)"
    - "Agent loop respects the CLI state (PAUSED = no execution)"
  artifacts:
    - path: "src/hydra/agent/loop.py"
      provides: "Complete autonomous agent loop state machine"
      exports: ["AgentLoop", "AgentPhase", "AgentCycleResult"]
    - path: "tests/agent/test_loop.py"
      provides: "Unit tests for agent loop step transitions"
    - path: "tests/agent/test_integration.py"
      provides: "Integration test of full observe-to-promote cycle with mocked dependencies"
  key_links:
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/sandbox/observer.py"
      via: "loop.step() calls observer.get_full_report() during OBSERVE phase"
      pattern: "observer\\.get_full_report"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/diagnostician.py"
      via: "loop.step() calls diagnostician.diagnose() during DIAGNOSE phase"
      pattern: "diagnostician\\.diagnose"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/hypothesis.py"
      via: "loop.step() calls hypothesis_engine.propose() during HYPOTHESIZE phase"
      pattern: "hypothesis_engine\\.propose"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/experiment_runner.py"
      via: "loop.step() calls experiment_runner.run() during EXPERIMENT phase"
      pattern: "experiment_runner\\.run"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/sandbox/evaluator.py"
      via: "loop.step() calls evaluator.score() during EVALUATE phase"
      pattern: "evaluator\\.score"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/autonomy.py"
      via: "loop checks require_permission() before each step"
      pattern: "require_permission"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/dedup.py"
      via: "loop checks is_duplicate() before experiment"
      pattern: "deduplicator\\.is_duplicate"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/budget.py"
      via: "loop checks can_run() before experiment"
      pattern: "budget\\.can_run"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/rollback.py"
      via: "loop feeds fitness to rollback trigger during EVALUATE"
      pattern: "rollback_trigger\\.update"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/agent/promotion.py"
      via: "loop calls promotion_evaluator.evaluate() to decide promotion"
      pattern: "promotion_evaluator\\.evaluate"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/sandbox/journal.py"
      via: "loop logs ExperimentRecord at each cycle completion"
      pattern: "journal\\.log_experiment"
    - from: "src/hydra/agent/loop.py"
      to: "src/hydra/cli/state.py"
      via: "loop checks get_state() == RUNNING before each cycle"
      pattern: "get_state"
---

<objective>
Wire all Phase 4 modules into the single-head autonomous agent loop state machine.

Purpose: AGNT-01 requires the complete observe -> diagnose -> hypothesize -> experiment -> evaluate loop running autonomously. This plan takes every module built in Plans 01-04 (LLM client, autonomy, rollback, promotion, diagnostician, hypothesis engine, experiment runner, dedup, budget) and wires them into a single AgentLoop class with explicit state transitions, permission checks, and journal logging. This is the central integration point -- the "Honda engine" assembled from its parts.

Output: `src/hydra/agent/loop.py` with the full agent loop, plus unit tests and an integration test demonstrating the complete cycle.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-agent-core-llm-integration/04-01-SUMMARY.md
@.planning/phases/04-agent-core-llm-integration/04-02-SUMMARY.md
@.planning/phases/04-agent-core-llm-integration/04-03-SUMMARY.md
@.planning/phases/04-agent-core-llm-integration/04-04-SUMMARY.md
@src/hydra/agent/autonomy.py
@src/hydra/agent/rollback.py
@src/hydra/agent/promotion.py
@src/hydra/agent/diagnostician.py
@src/hydra/agent/hypothesis.py
@src/hydra/agent/experiment_runner.py
@src/hydra/agent/dedup.py
@src/hydra/agent/budget.py
@src/hydra/agent/llm/client.py
@src/hydra/agent/llm/schemas.py
@src/hydra/sandbox/observer.py
@src/hydra/sandbox/evaluator.py
@src/hydra/sandbox/journal.py
@src/hydra/sandbox/registry.py
@src/hydra/cli/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agent loop state machine with step transitions</name>
  <files>
    src/hydra/agent/loop.py
    src/hydra/agent/__init__.py
  </files>
  <action>
**loop.py** -- The single-head autonomous agent loop (AGNT-01):

- `AgentPhase(str, Enum)`: IDLE, OBSERVE, DIAGNOSE, HYPOTHESIZE, EXPERIMENT, EVALUATE, PROMOTE, COOLDOWN

- `AgentCycleResult(dataclass)`: phase_reached (AgentPhase), diagnosis (DiagnosisResult | None), hypothesis (Hypothesis | None), experiment_result (ExperimentResult | None), promoted (bool), rolled_back (bool), skipped_reason (str | None), duration_seconds (float)

- `AgentLoop` class:
  - `__init__` accepts all dependencies via constructor injection:
    - observer: DriftObserver
    - diagnostician: Diagnostician
    - hypothesis_engine: HypothesisEngine
    - experiment_runner: ExperimentRunner
    - evaluator: CompositeEvaluator
    - journal: ExperimentJournal
    - registry: ModelRegistry
    - rollback_trigger: HysteresisRollbackTrigger
    - promotion_evaluator: PromotionEvaluator
    - deduplicator: HypothesisDeduplicator
    - budget: MutationBudget
    - autonomy_level: AutonomyLevel (default SUPERVISED)
    - llm_client: LLMClient | None (default None)
  - `_phase: AgentPhase` tracking current state
  - `_current_cycle: dict` accumulating results for the current cycle

  - `run_cycle(self, recent_returns, predictions, actuals, probabilities, baseline_sharpe, baseline_features=None, current_features=None, feature_names=None, current_config=None, champion_fitness=None) -> AgentCycleResult`:
    Main entry point -- runs one complete cycle through all phases. Steps:

    1. **Check CLI state**: Call `get_state()`. If PAUSED, return AgentCycleResult with skipped_reason="Agent paused".

    2. **OBSERVE**: Check autonomy permission for "observe". Call `observer.get_full_report(...)`. If `report.needs_diagnosis` is False, return AgentCycleResult with phase_reached=OBSERVE and skipped_reason="No drift detected".

    3. **DIAGNOSE**: Check autonomy permission for "diagnose". Call `diagnostician.diagnose(report)`. Log diagnosis to structlog. If diagnosis confidence is very low (< 0.3) and no clear cause, return with skipped_reason="Diagnosis inconclusive".

    4. **HYPOTHESIZE**: Check autonomy permission for "hypothesize". Call `hypothesis_engine.propose(diagnosis, current_config)`. Check dedup: `deduplicator.is_duplicate(hypothesis.description)` -- if duplicate, try propose_multiple and pick first non-duplicate. If ALL are duplicates, return with skipped_reason="All hypotheses are duplicates of recent experiments". Check budget: `budget.can_run(hypothesis.mutation_type)` -- if blocked, return with skipped_reason from budget.

    5. **EXPERIMENT**: Check autonomy permission for "experiment". Call `experiment_runner.run(hypothesis, current_config or {})`. If ExperimentResult.success is False, log the failure, record to journal as "rejected", and return.

    6. **EVALUATE**: Feed current fitness to rollback trigger: `rollback_trigger.update(current_fitness, champion_fitness)`. If rollback fires, call `registry.rollback()` (if method exists), log to journal, return with rolled_back=True. Otherwise, evaluate candidate via promotion evaluator. For the Honda version, use a simplified promotion check: compare experiment fitness against champion_fitness. If experiment fitness > champion_fitness (simple comparison for now -- full 5-window evaluation requires running MarketReplayEngine 5 times which Plan 05 wires at integration level), set promoted=True.

    7. **PROMOTE/REJECT**: Check autonomy permission for "promote" if promoted. Log ExperimentRecord to journal with all details. Register hypothesis in deduplicator. Record in budget. Return complete AgentCycleResult.

  - `set_autonomy_level(self, level: AutonomyLevel) -> None`: Update the autonomy level at runtime.

Update `src/hydra/agent/__init__.py` to export the key public API:
```python
from hydra.agent.loop import AgentLoop, AgentPhase, AgentCycleResult
from hydra.agent.autonomy import AutonomyLevel, check_permission, PermissionDeniedError
from hydra.agent.diagnostician import Diagnostician
from hydra.agent.hypothesis import HypothesisEngine, MUTATION_PLAYBOOK
from hydra.agent.experiment_runner import ExperimentRunner, ExperimentResult
from hydra.agent.rollback import HysteresisRollbackTrigger, RollbackConfig
from hydra.agent.promotion import PromotionEvaluator, PromotionConfig
from hydra.agent.dedup import HypothesisDeduplicator
from hydra.agent.budget import MutationBudget, BudgetConfig
```
  </action>
  <verify>
`python -c "from hydra.agent.loop import AgentLoop, AgentPhase, AgentCycleResult; print('loop imports OK')"` succeeds.
`python -c "from hydra.agent import AgentLoop, AutonomyLevel, Diagnostician, HypothesisEngine; print('package API OK')"` succeeds.
  </verify>
  <done>AgentLoop class wires all modules into a single cycle. Each step checks autonomy permissions. Dedup, budget, and cooldown are checked before experiments. Rollback fires on sustained degradation. Journal logging captures the full cycle. CLI state gating prevents execution when paused.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests and integration test for agent loop</name>
  <files>
    tests/agent/test_loop.py
    tests/agent/test_integration.py
  </files>
  <action>
**test_loop.py** -- Unit tests for AgentLoop step transitions:

Use unittest.mock to create mock versions of all dependencies (observer, diagnostician, hypothesis_engine, experiment_runner, evaluator, journal, registry, rollback_trigger, promotion_evaluator, deduplicator, budget). Each test verifies one behavior:

- Test PAUSED state: mock get_state() to return PAUSED -> AgentCycleResult.skipped_reason contains "paused"
- Test no drift: mock observer.get_full_report() to return DriftReport(needs_diagnosis=False) -> phase_reached=OBSERVE, skipped_reason="No drift"
- Test LOCKDOWN blocks observe: set autonomy to LOCKDOWN -> PermissionDeniedError or skipped_reason
- Test SUPERVISED blocks experiment: mock through to HYPOTHESIZE, set autonomy=SUPERVISED -> skipped at experiment
- Test duplicate hypothesis: mock deduplicator.is_duplicate to return (True, 0.92) -> skipped_reason about duplicates
- Test budget exceeded: mock budget.can_run to return (False, "budget exceeded") -> skipped_reason
- Test experiment failure: mock experiment_runner.run to return ExperimentResult(success=False) -> journal records rejection
- Test rollback triggered: mock rollback_trigger.update to return True -> rolled_back=True
- Test successful cycle: all mocks return positive results -> promoted=True, journal.log_experiment called
- Test journal logging: verify ExperimentRecord is created with correct hypothesis, mutation_type, config_diff, results, promotion_decision

**test_integration.py** -- Integration test with real (non-mock) modules:

Create a full integration test that instantiates real objects (not mocks) for a complete cycle:
1. Create real DriftObserver, Diagnostician (no LLM), HypothesisEngine, ExperimentRunner, CompositeEvaluator, ExperimentJournal (temp SQLite), HysteresisRollbackTrigger, PromotionEvaluator, HypothesisDeduplicator, MutationBudget
2. Set autonomy to AUTONOMOUS
3. Create synthetic drift data: returns that produce sharpe_degraded=True
4. Call agent_loop.run_cycle() with the synthetic data
5. Verify: cycle completes without error, journal has 1 entry, diagnosis was produced, hypothesis was from playbook
6. This test proves the full pipeline works end-to-end with zero LLM calls (the "Honda" path)

Use `pytest.fixture` for the ExperimentJournal with tmp_path for SQLite. Use `unittest.mock.patch("hydra.cli.state.get_state")` to return RUNNING. For the deduplicator, use a mock sentence-transformers model (or skip loading the real model in tests to avoid heavy dependency -- use `unittest.mock.patch` on `SentenceTransformer` constructor to return a mock that produces random 384-dim embeddings).
  </action>
  <verify>
`cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/agent/test_loop.py tests/agent/test_integration.py -v` -- all tests pass.
  </verify>
  <done>Agent loop has comprehensive unit test coverage for every state transition and guard rail. Integration test proves the complete observe-diagnose-hypothesize-experiment-evaluate cycle works end-to-end with zero LLM calls. The "Honda engine" is fully assembled and tested.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/agent/ -v` -- all agent tests pass (loop, integration, autonomy, rollback, promotion, diagnostician, hypothesis, experiment runner, dedup, budget, llm client)
- Agent loop: full cycle from drift detection to promotion/rejection with journal logging
- Zero LLM calls: entire cycle works with no API keys configured
- Autonomy gating: each step respects permission levels
- Guardrails: dedup, budget, cooldown, rollback all enforced in the loop
- CLI integration: PAUSED state prevents execution
</verification>

<success_criteria>
The single-head autonomous agent loop is complete and tested. It detects drift, diagnoses root causes (rule-based), proposes mutations from the playbook, runs experiments in subprocess isolation, evaluates results, and promotes winners -- all without human intervention when autonomy is set to AUTONOMOUS. All guardrails (autonomy, rollback, dedup, budget, cooldowns) are wired in. The system works with zero LLM API keys (AGNT-10 is the default mode). This is the "Honda engine" -- ready to be turbocharged with multi-head architecture in a future phase.
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-core-llm-integration/04-05-SUMMARY.md`
</output>
