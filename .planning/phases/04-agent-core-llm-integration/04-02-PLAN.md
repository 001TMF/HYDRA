---
phase: 04-agent-core-llm-integration
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/hydra/agent/autonomy.py
  - src/hydra/agent/rollback.py
  - src/hydra/agent/promotion.py
  - tests/agent/__init__.py
  - tests/agent/test_autonomy.py
  - tests/agent/test_rollback.py
  - tests/agent/test_promotion.py
autonomous: true
requirements: [AGNT-06, AGNT-07, AGNT-08]

must_haves:
  truths:
    - "Autonomy levels gate agent actions: lockdown blocks everything, supervised allows observe/diagnose but not experiment/promote, autonomous allows all"
    - "Rollback triggers after sustained degradation (N consecutive bad periods) but not on a single bad check"
    - "Rollback does not re-trigger during cooldown period (hysteresis prevents flapping)"
    - "Candidate promotion requires beating champion on 3 of 5 independent evaluation windows"
  artifacts:
    - path: "src/hydra/agent/autonomy.py"
      provides: "AutonomyLevel enum and permission gating"
      exports: ["AutonomyLevel", "check_permission", "PermissionDeniedError"]
    - path: "src/hydra/agent/rollback.py"
      provides: "Hysteresis-based rollback trigger"
      exports: ["RollbackConfig", "HysteresisRollbackTrigger"]
    - path: "src/hydra/agent/promotion.py"
      provides: "3-of-5 window promotion evaluation"
      exports: ["PromotionConfig", "PromotionEvaluator", "PromotionResult"]
  key_links:
    - from: "src/hydra/agent/rollback.py"
      to: "src/hydra/agent/loop.py"
      via: "rollback trigger result is consumed by loop.py during EVALUATE phase (wired in 04-05)"
      pattern: "HysteresisRollbackTrigger"
    - from: "src/hydra/agent/promotion.py"
      to: "src/hydra/agent/loop.py"
      via: "promotion evaluator result is consumed by loop.py during EVALUATE phase (wired in 04-05)"
      pattern: "PromotionEvaluator"
---

<objective>
Build the three guardrail modules: autonomy gating, hysteresis rollback, and 3-of-5 promotion evaluation.

Purpose: These are safety-critical components that prevent the agent from doing damage. Autonomy gating (AGNT-06) controls what actions are allowed. Rollback (AGNT-07) reverts bad promotions. Promotion (AGNT-08) ensures candidates genuinely outperform champions before replacing them. All three are pure logic with no LLM dependency -- they work in both rule-based and LLM-enhanced modes.

Output: Three modules in `src/hydra/agent/` with comprehensive test coverage.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-agent-core-llm-integration/04-RESEARCH.md
@src/hydra/sandbox/evaluator.py
@src/hydra/sandbox/registry.py
@src/hydra/cli/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Autonomy levels and permission gating (TDD)</name>
  <files>
    src/hydra/agent/autonomy.py
    tests/agent/__init__.py
    tests/agent/test_autonomy.py
  </files>
  <action>
**tests/agent/__init__.py** -- Create idempotently (empty file; `touch tests/agent/__init__.py` or `open("tests/agent/__init__.py", "a").close()`). This plan runs in parallel with 04-01, 04-03, and 04-04, all of which write to `tests/agent/`. Each must create this file idempotently so whichever plan runs first wins and subsequent plans are no-ops.

**autonomy.py** -- Four-level autonomy system gating agent actions:
- `AutonomyLevel(IntEnum)`: LOCKDOWN=0, SUPERVISED=1, SEMI_AUTO=2, AUTONOMOUS=3
- `PermissionDeniedError(Exception)`: raised when an action is blocked by current autonomy level. Include the action name and current level in the message.
- `PERMISSIONS` dict mapping action names to required minimum autonomy level:
  - observe: SUPERVISED (1)
  - diagnose: SUPERVISED (1)
  - hypothesize: SUPERVISED (1)
  - experiment: SEMI_AUTO (2)
  - promote: AUTONOMOUS (3)
  - rollback: SUPERVISED (1) -- always allow rollback except lockdown
- `check_permission(action: str, level: AutonomyLevel) -> bool`: Returns True if action is allowed at the given level.
- `require_permission(action: str, level: AutonomyLevel) -> None`: Raises PermissionDeniedError if not allowed. Used as a guard at the start of agent loop steps.
- `get_allowed_actions(level: AutonomyLevel) -> list[str]`: Returns all actions allowed at this level.

Design note: Use minimum-level comparison (`level >= PERMISSIONS[action]`), not the nested dict from research. Simpler, less error-prone.

**test_autonomy.py** -- Comprehensive tests:
- LOCKDOWN blocks all actions
- SUPERVISED allows observe/diagnose/hypothesize/rollback, blocks experiment/promote
- SEMI_AUTO allows experiment, blocks promote
- AUTONOMOUS allows everything
- PermissionDeniedError raised with descriptive message
- Unknown action returns False (not KeyError)
- get_allowed_actions returns correct set for each level
  </action>
  <verify>
`cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/agent/test_autonomy.py -v` -- all tests pass.
  </verify>
  <done>AutonomyLevel enum and permission gating work correctly. LOCKDOWN blocks all, SUPERVISED allows observe/diagnose, AUTONOMOUS allows all. PermissionDeniedError is descriptive. Tests cover every level/action combination.</done>
</task>

<task type="auto">
  <name>Task 2: Hysteresis rollback and 3-of-5 promotion (TDD)</name>
  <files>
    src/hydra/agent/rollback.py
    src/hydra/agent/promotion.py
    tests/agent/test_rollback.py
    tests/agent/test_promotion.py
  </files>
  <action>
**rollback.py** -- Hysteresis-based rollback trigger (AGNT-07):
- `RollbackConfig(dataclass)`: degradation_threshold (float, default 0.15 = 15% fitness drop), sustained_periods (int, default 3), recovery_periods (int, default 5), cooldown_after_rollback (int, default 10)
- `HysteresisRollbackTrigger`:
  - `__init__(config: RollbackConfig | None)`: Initialize with counters zeroed, armed=True
  - `update(current_fitness: float, champion_fitness: float) -> bool`: Core logic per research Pattern 6. Returns True if rollback should execute. Key states:
    - During cooldown: decrement counter, return False
    - If degraded (drop > threshold): increment degraded_count, reset healthy_count
    - If healthy: increment healthy_count, reset degraded_count
    - If armed and degraded_count >= sustained_periods: trigger rollback, disarm, start cooldown
    - If disarmed and healthy_count >= recovery_periods: re-arm
  - `reset()`: Reset all state (for testing or manual override)
  - Property `is_armed -> bool`, `cooldown_remaining -> int`, `consecutive_degraded -> int`

**promotion.py** -- 3-of-5 window promotion evaluation (AGNT-08):
- `PromotionConfig(dataclass)`: n_windows (int, default 5), required_wins (int, default 3), min_improvement (float, default 0.0 -- candidate must strictly beat champion)
- `PromotionResult(dataclass)`: promoted (bool), windows_won (int), window_scores (list of tuples: (candidate_fitness, champion_fitness)), reason (str)
- `PromotionEvaluator`:
  - `__init__(config: PromotionConfig | None)`: Store config
  - `evaluate(candidate_scores: list[float], champion_scores: list[float]) -> PromotionResult`: Takes fitness scores for candidate and champion on each of N disjoint evaluation windows. Candidate wins a window if `candidate_score > champion_score + config.min_improvement`. Returns PromotionResult with win count and detailed per-window comparison.
  - Validation: candidate_scores and champion_scores must have same length == config.n_windows. Raise ValueError otherwise.

**test_rollback.py**:
- Single bad period does NOT trigger rollback (needs sustained_periods=3)
- Three consecutive degraded periods triggers rollback
- After rollback, cooldown prevents re-trigger for N periods
- After cooldown, trigger re-arms after recovery_periods healthy checks
- Edge case: exactly at threshold does NOT trigger (must exceed)
- Custom config values work (sustained_periods=1 triggers on first bad check)
- Reset clears all state

**test_promotion.py**:
- Candidate winning 3 of 5 windows -> promoted=True
- Candidate winning 2 of 5 windows -> promoted=False
- Candidate winning 5 of 5 windows -> promoted=True
- Candidate winning 0 of 5 windows -> promoted=False
- Tied scores (equal fitness) -> candidate does NOT win that window (must strictly beat)
- min_improvement > 0 requires candidate to exceed champion by margin
- Mismatched list lengths raises ValueError
- Window scores captured in result for audit trail
  </action>
  <verify>
`cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/agent/test_rollback.py tests/agent/test_promotion.py -v` -- all tests pass.
  </verify>
  <done>Hysteresis rollback triggers only on sustained degradation, not single bad periods. Cooldown and re-arming prevent flapping. 3-of-5 promotion requires genuine outperformance across independent windows. All edge cases tested.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/agent/test_autonomy.py tests/agent/test_rollback.py tests/agent/test_promotion.py -v` -- all pass
- Autonomy: LOCKDOWN blocks everything, AUTONOMOUS allows everything
- Rollback: 3 consecutive degraded periods triggers, cooldown prevents re-trigger
- Promotion: 3-of-5 wins required, ties don't count as wins
</verification>

<success_criteria>
Three guardrail modules are built with full test coverage. They are pure logic with no LLM dependency. Any autonomy level can be configured. Rollback has hysteresis. Promotion requires 3-of-5 wins. These modules will be wired into the agent loop in Plan 05.
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-core-llm-integration/04-02-SUMMARY.md`
</output>
