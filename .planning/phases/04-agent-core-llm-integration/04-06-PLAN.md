---
phase: 04-agent-core-llm-integration
plan: 06
type: execute
wave: 4
depends_on: [04-04, 04-05]
files_modified:
  - src/hydra/agent/scheduler.py
  - src/hydra/agent/__init__.py
  - tests/test_scheduler.py
  - tests/test_integration.py
autonomous: true
requirements: [AGNT-18]

must_haves:
  truths:
    - "Technical Head runs every cycle, Research Head weekly, Structural Head monthly"
    - "Scheduling frequencies are adjusted by head reputation multiplier"
    - "The full agent package exports a clean public API"
    - "End-to-end integration test demonstrates full cycle: observe -> diagnose -> hypothesize (multi-head) -> experiment -> evaluate -> promote/reject"
    - "Budget manager dynamically adjusts based on head results -- heads producing winners get more budget"
  artifacts:
    - path: "src/hydra/agent/scheduler.py"
      provides: "Head scheduling with frequency and budget management"
      exports: ["HeadScheduler"]
    - path: "src/hydra/agent/__init__.py"
      provides: "Clean public API for agent package"
      exports: ["AgentLoop", "HeadCoordinator", "Arena", "LLMClient"]
  key_links:
    - from: "src/hydra/agent/scheduler.py"
      to: "src/hydra/agent/budget.py"
      via: "BudgetManager for reputation-adjusted scheduling"
      pattern: "BudgetManager|HeadReputation"
    - from: "src/hydra/agent/scheduler.py"
      to: "src/hydra/agent/coordinator.py"
      via: "HeadCoordinator.heads filtered by schedule eligibility"
      pattern: "HeadCoordinator|heads"
    - from: "tests/test_integration.py"
      to: "src/hydra/agent/loop.py"
      via: "AgentLoop.run_cycle() with all real components (mocked externals)"
      pattern: "run_cycle"
---

<objective>
Build the head scheduling system and create integration tests that verify the complete multi-headed agent cycle works end-to-end.

Purpose: Scheduling balances cost vs exploration -- Technical Head runs often (cheap, incremental), Research Head runs weekly (expensive, exploratory), Structural Head runs monthly (architectural changes need time to prove). The integration test is the capstone that proves all Phase 4 components wire together correctly.

Output: Scheduler module, updated package __init__.py, and integration test suite.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-agent-core-llm-integration/04-RESEARCH.md
@.planning/phases/04-agent-core-llm-integration/04-04-SUMMARY.md
@.planning/phases/04-agent-core-llm-integration/04-05-SUMMARY.md
@.planning/phases/04-agent-core-llm-integration/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create head scheduler and update agent package exports</name>
  <files>
    src/hydra/agent/scheduler.py
    src/hydra/agent/__init__.py
    tests/test_scheduler.py
  </files>
  <action>
    **Create `src/hydra/agent/scheduler.py`**:
    - `ScheduleConfig` dataclass: head_name (str), base_interval_cycles (int), last_run_cycle (int = 0), enabled (bool = True).
    - `HeadScheduler`:
      - `__init__(self, budget_manager: BudgetManager, configs: list[ScheduleConfig] | None = None)`:
        Default configs if None:
        - ScheduleConfig("technical", base_interval_cycles=1) -- every cycle
        - ScheduleConfig("research", base_interval_cycles=7) -- weekly (assuming 1 cycle/day)
        - ScheduleConfig("structural", base_interval_cycles=30) -- monthly
      - `get_eligible_heads(self, current_cycle: int) -> list[str]`: For each config, check if `current_cycle - last_run_cycle >= effective_interval`. Effective interval = `base_interval_cycles / budget_multiplier` (rounded up, minimum 1). Higher reputation = shorter interval (more frequent runs). Return list of eligible head names.
      - `mark_run(self, head_name: str, current_cycle: int) -> None`: Update last_run_cycle for that head.
      - `adjust_from_budget(self, head_name: str) -> int`: Return the effective interval for a head based on budget multiplier.
      - `get_schedule_report(self) -> list[dict]`: Summary of all heads' schedules, next eligible cycle, and effective intervals.

    **Update `src/hydra/agent/__init__.py`**: Comprehensive package exports.
    ```python
    from hydra.agent.loop import AgentLoop, AgentPhase, AgentState
    from hydra.agent.coordinator import HeadCoordinator
    from hydra.agent.arena import Arena, ArenaResult
    from hydra.agent.diagnostician import Diagnostician
    from hydra.agent.hypothesis import HypothesisEngine, MUTATION_PLAYBOOK
    from hydra.agent.experiment_runner import ExperimentRunner, ExperimentResult
    from hydra.agent.autonomy import AutonomyLevel, check_permission
    from hydra.agent.rollback import HysteresisRollbackTrigger, RollbackConfig
    from hydra.agent.promotion import PromotionEvaluator, PromotionResult
    from hydra.agent.dedup import HypothesisDeduplicator
    from hydra.agent.budget import HeadReputation, BudgetManager
    from hydra.agent.scheduler import HeadScheduler, ScheduleConfig
    ```

    **Create `tests/test_scheduler.py`**:
    1. test_technical_eligible_every_cycle: Technical head (interval=1) eligible on every cycle.
    2. test_research_eligible_after_7_cycles: Research head (interval=7) not eligible on cycle 3, eligible on cycle 7.
    3. test_structural_eligible_after_30_cycles: Structural head (interval=30) eligible only after 30 cycles.
    4. test_mark_run_updates_last_cycle: After mark_run, head not eligible until next interval.
    5. test_reputation_adjusts_interval: Head with 2.0 budget_multiplier has halved interval (runs twice as often).
    6. test_low_reputation_extends_interval: Head with 0.25 budget_multiplier has 4x interval (runs less often).
    7. test_disabled_head_never_eligible: Set enabled=False -> never appears in eligible list.
    8. test_schedule_report_structure: get_schedule_report returns list of dicts with expected keys.

    For reputation tests: set up BudgetManager with pre-configured HeadReputation scores to control the multiplier.
  </action>
  <verify>Run `python -m pytest tests/test_scheduler.py -v` -- all 8 tests pass.</verify>
  <done>Head scheduler correctly implements frequency-based scheduling with reputation-adjusted intervals. Technical runs every cycle, Research weekly, Structural monthly. Successful heads run more frequently. 8 tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: End-to-end integration test of complete multi-headed agent cycle</name>
  <files>tests/test_integration.py</files>
  <action>
    Create an integration test that wires ALL Phase 4 components together and runs a complete agent cycle with mocked externals (no real LLM calls, no real API calls, no real model training).

    **Test setup fixture** (`@pytest.fixture`):
    - Create mock DriftObserver that returns a DriftReport with needs_diagnosis=True, performance degradation signals.
    - Create Diagnostician with llm_client=None (rule-based mode).
    - Create HypothesisEngine with llm_client=None (rule-based mode).
    - Create TechnicalHead wrapping the HypothesisEngine.
    - Create StructuralHead with llm_client=None.
    - Create ResearchHead with llm_client=None and no data sources (degraded mode).
    - Create HeadCoordinator and register all 3 heads.
    - Create mock ExperimentRunner that returns ExperimentResult(success=True, metrics={"sharpe": 0.8, "drawdown": 0.10, ...}).
    - Create CompositeEvaluator with default weights.
    - Create PromotionEvaluator with default 3-of-5.
    - Create Arena with evaluator, experiment_runner, promotion_evaluator.
    - Create ExperimentJournal with temp SQLite file.
    - Create HysteresisRollbackTrigger with default config.
    - Create BudgetManager with 3 heads registered.
    - Create HeadScheduler with default configs.
    - Create AgentLoop wiring everything together at AutonomyLevel.AUTONOMOUS.

    **Tests**:
    1. test_full_cycle_autonomous: Run agent_loop.run_cycle(). Verify:
       - Loop progressed through all phases (IDLE -> OBSERVE -> DIAGNOSE -> HYPOTHESIZE -> EXPERIMENT -> EVALUATE -> IDLE).
       - At least 1 hypothesis was generated.
       - Journal has at least 1 entry after the cycle.
       - Cycle count incremented.
    2. test_full_cycle_supervised_blocks_experiment: Same setup but autonomy=SUPERVISED. Verify cycle stops at HYPOTHESIZE (experiment blocked).
    3. test_scheduler_filters_heads: Create coordinator with all 3 heads. At cycle=1, scheduler.get_eligible_heads should include "technical" but NOT "research" or "structural". Verify coordinator only dispatches to eligible heads when filtered.
    4. test_budget_updates_after_cycle: Run a cycle that results in promotion. Verify budget_manager.get_experiment_budget("technical") reflects the updated reputation.
    5. test_dedup_prevents_repeat_hypothesis: Run two cycles with same diagnosis. Second cycle should have dedup filtering some hypotheses that were already tried in cycle 1 (loaded from journal).
    6. test_rollback_triggers_after_degradation: Simulate 3 consecutive degraded fitness readings via rollback_trigger.update(). Verify rollback fires on the 3rd.

    These tests verify the wiring between ALL modules -- not testing individual module logic (that's in unit tests), but testing that modules correctly pass data to each other.
  </action>
  <verify>Run `python -m pytest tests/test_integration.py -v` -- all 6 tests pass.</verify>
  <done>End-to-end integration test proves all Phase 4 components wire together. Full agent cycle runs autonomously with 3 heads, dedup, scheduling, budget management, and journal logging. All 6 tests pass.</done>
</task>

</tasks>

<verification>
1. `python -c "from hydra.agent import AgentLoop, HeadCoordinator, Arena, LLMClient, Diagnostician, HypothesisEngine, ExperimentRunner, AutonomyLevel, HysteresisRollbackTrigger, PromotionEvaluator, HypothesisDeduplicator, BudgetManager, HeadScheduler"` -- all imports succeed
2. `python -m pytest tests/test_scheduler.py tests/test_integration.py -v` -- all 14 tests pass
3. Full cycle test demonstrates: observe -> diagnose -> hypothesize (multi-head) -> experiment -> evaluate -> journal log
4. Scheduler correctly gates head execution by cycle count and reputation
5. Budget manager adjusts based on head outcomes
6. Dedup prevents repeat hypotheses across cycles
</verification>

<success_criteria>
Head scheduler implements reputation-adjusted frequency scheduling. Integration test demonstrates complete multi-headed agent cycle with all Phase 4 components wired together. Agent package has clean public API. All 14 tests pass. Phase 4 success criteria verifiable:
1. Single-head loop works end-to-end (test_full_cycle_autonomous)
2. LLM client with fallback chain (04-01 tests)
3. Autonomy levels gate actions (test_full_cycle_supervised_blocks_experiment)
4. Rollback with hysteresis (test_rollback_triggers_after_degradation + 04-02 tests)
5. Dedup + budgets prevent degenerate loops (test_dedup_prevents_repeat_hypothesis + 04-02 tests)
6. Coordinator dispatches to multiple heads (test_full_cycle_autonomous)
7. Research Head discovers signals (04-05 tests)
8. Reputation scoring adjusts budgets (test_budget_updates_after_cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-core-llm-integration/04-06-SUMMARY.md`
</output>
