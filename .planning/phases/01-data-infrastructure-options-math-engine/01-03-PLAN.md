---
phase: 01-data-infrastructure-options-math-engine
plan: 03
type: tdd
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/hydra/signals/options_math/surface.py
  - tests/test_svi_surface.py
autonomous: true
requirements:
  - OPTS-03

must_haves:
  truths:
    - "SVI calibration fits a volatility smile to market implied volatilities with RMSE < 2% for clean data"
    - "SVI produces reasonable interpolated vols for strikes outside the observed range"
    - "Butterfly arbitrage check detects invalid (non-convex) surfaces"
    - "SVI handles sparse data (8-15 points) without blowing up"
  artifacts:
    - path: "src/hydra/signals/options_math/surface.py"
      provides: "SVI volatility surface calibration and interpolation"
      exports: ["calibrate_svi", "svi_total_variance", "SVICalibrationResult"]
      min_lines: 80
    - path: "tests/test_svi_surface.py"
      provides: "TDD tests for SVI calibration"
      min_lines: 80
  key_links:
    - from: "src/hydra/signals/options_math/surface.py"
      to: "scipy.optimize.minimize"
      via: "L-BFGS-B minimization of SVI parameters"
      pattern: "minimize.*L-BFGS-B"
---

<objective>
Implement SVI volatility surface calibration using TDD. This is the mathematical core that smooths noisy thin-market implied volatilities before Breeden-Litzenberger density extraction.

Purpose: Direct B-L on raw option prices from thin markets fails (research pitfall #1). SVI smoothing is the prerequisite -- without a stable vol surface, the density extraction in Plan 04 will produce garbage. This is pure math with well-defined inputs and outputs, making it an ideal TDD candidate.

Output: A working SVI calibrator that fits 5 SVI parameters to market implied vols, validates against butterfly arbitrage, and handles sparse data (8-15 strikes) typical of thin markets.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-infrastructure-options-math-engine/01-RESEARCH.md
</context>

<feature>
  <name>SVI Volatility Surface Calibration</name>
  <files>src/hydra/signals/options_math/surface.py, tests/test_svi_surface.py</files>
  <behavior>
    SVI parameterization: w(k) = a + b * (rho * (k - m) + sqrt((k - m)^2 + sigma^2))
    where k = ln(K/F) is log-moneyness, w is total implied variance (iv^2 * T).

    Cases (input -> expected output):
    1. Flat vol smile (all IVs = 0.30, T=0.5): SVI fit should recover near-flat surface, RMSE < 0.001
    2. Typical skewed smile (10 strikes, IVs from 0.35 down to 0.25): SVI fit RMSE < 0.02
    3. Sparse data (8 strikes with 5% noise added): SVI fit still converges, no NaN/Inf
    4. Butterfly arbitrage detection: manually create a surface with d2w/dk2 < 0, flag must trigger
    5. Very sparse data (5 strikes): should still produce a result but with higher RMSE and a warning
    6. Call prices from SVI: Given fitted SVI params, compute smooth call prices via Black-76 for B-L input

    Functions:
    - svi_total_variance(k, a, b, rho, m, sigma) -> w (vectorized)
    - calibrate_svi(strikes, market_ivs, forward, T) -> SVICalibrationResult
    - svi_to_call_prices(svi_params, strikes_fine, forward, r, T) -> call_prices (for B-L input)

    SVICalibrationResult dataclass:
    - params: dict with a, b, rho, m, sigma
    - fitted_iv: np.ndarray of fitted implied vols at input strikes
    - rmse: float
    - has_butterfly_arbitrage: bool
    - warnings: list[str]
  </behavior>
  <implementation>
    Follow the SVI calibration code from research exactly:
    1. Convert strikes to log-moneyness k = ln(K/F)
    2. Convert market IVs to total variance w = iv^2 * T
    3. Minimize sum of squared differences between model w and market w
    4. Use L-BFGS-B with bounds: a in (-1, 1), b in (0, 5), rho in (-0.99, 0.99), m in (-2, 2), sigma in (0.01, 5)
    5. Initial guess: a = mean(market_w), b = 0.1, rho = -0.3, m = 0.0, sigma = 0.5
    6. After fit: check convexity (d2w/dk2 >= 0 over fine grid) for butterfly arbitrage
    7. Convert fitted total variance back to implied vol for output
    8. svi_to_call_prices: Use Black-76 formula to convert smooth SVI vols -> call prices for downstream B-L

    Use NumPy for all array operations. SciPy minimize for optimization. No QuantLib needed.
  </implementation>
</feature>

<verification>
1. `uv run pytest tests/test_svi_surface.py -v` -- all tests pass
2. Flat vol test: RMSE < 0.001
3. Skewed smile test: RMSE < 0.02
4. Sparse data (8 points): converges without error
5. Butterfly arbitrage detection works on constructed invalid surface
</verification>

<success_criteria>
- SVI calibrates to clean data with RMSE < 2% implied vol
- SVI handles thin-market sparse data (8-15 strikes) gracefully
- Butterfly arbitrage check detects invalid surfaces
- svi_to_call_prices produces smooth call prices suitable for B-L differentiation
- All TDD tests pass (RED -> GREEN -> REFACTOR cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-infrastructure-options-math-engine/01-03-SUMMARY.md`
</output>
