---
phase: 01-data-infrastructure-options-math-engine
plan: 04
type: tdd
wave: 3
depends_on:
  - 01-03
files_modified:
  - src/hydra/signals/options_math/density.py
  - src/hydra/signals/options_math/moments.py
  - tests/test_bl_density.py
  - tests/test_implied_moments.py
autonomous: true
requirements:
  - OPTS-01
  - OPTS-02
  - OPTS-05

must_haves:
  truths:
    - "B-L extracts an implied density from SVI-smoothed call prices that integrates to ~1.0"
    - "Implied density mean is within 2% of forward price for short-dated options"
    - "Implied moments (mean, variance, skew, kurtosis) are numerically stable across consecutive days"
    - "When fewer than 8 liquid strikes are available, system returns ATM IV only with quality=degraded"
    - "Negative density values are clipped to zero with a warning"
  artifacts:
    - path: "src/hydra/signals/options_math/density.py"
      provides: "Breeden-Litzenberger density extraction with graceful degradation"
      exports: ["extract_density", "ImpliedDensityResult", "DataQuality"]
      min_lines: 80
    - path: "src/hydra/signals/options_math/moments.py"
      provides: "Implied moments computed from B-L density"
      exports: ["compute_moments", "ImpliedMoments"]
      min_lines: 40
    - path: "tests/test_bl_density.py"
      provides: "B-L density extraction tests including degradation"
      min_lines: 80
  key_links:
    - from: "src/hydra/signals/options_math/density.py"
      to: "src/hydra/signals/options_math/surface.py"
      via: "svi_to_call_prices for smoothed call price input"
      pattern: "svi_to_call_prices"
    - from: "src/hydra/signals/options_math/moments.py"
      to: "src/hydra/signals/options_math/density.py"
      via: "Takes ImpliedDensityResult as input"
      pattern: "ImpliedDensityResult"
---

<objective>
Implement Breeden-Litzenberger risk-neutral density extraction and implied moments computation using TDD. This is the core of the phase validation gate: can B-L produce stable distributions from thin-market options?

Purpose: The density extraction is HYDRA's primary information source -- it tells us what the options market thinks will happen. The implied moments (mean, variance, skew, kurtosis) are the features that feed the divergence signal in Phase 2. Graceful degradation (OPTS-05) ensures the system doesn't produce garbage when data quality drops below thresholds.

Output: Working B-L density extractor that operates on SVI-smoothed call prices, moments calculator, and graceful degradation to ATM IV when data is insufficient.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-infrastructure-options-math-engine/01-RESEARCH.md
@.planning/phases/01-data-infrastructure-options-math-engine/01-03-SUMMARY.md
</context>

<feature>
  <name>Breeden-Litzenberger Density Extraction + Implied Moments</name>
  <files>
    src/hydra/signals/options_math/density.py
    src/hydra/signals/options_math/moments.py
    tests/test_bl_density.py
    tests/test_implied_moments.py
  </files>
  <behavior>
    **density.py:**
    extract_density(strikes, call_prices, oi, bid_ask_spread_pct, spot, r, T, min_liquid_strikes=8, max_spread_pct=0.20, min_oi=50) -> ImpliedDensityResult

    Cases:
    1. Full quality (20 liquid strikes, clean data): Density integrates to ~1.0 (+/- 0.05), mean within 2% of forward
    2. Degraded (5 liquid strikes): Returns quality=DEGRADED, atm_iv set, density/strikes are trivial
    3. Negative density regions: Clipped to zero, warning issued, renormalized
    4. SVI-smoothed input: Uses svi_to_call_prices from surface.py for smooth call prices before differentiating
    5. Log-normal benchmark: For Black-76 prices with known vol, B-L should recover approximately log-normal density

    DataQuality enum: FULL, DEGRADED, STALE, MISSING

    ImpliedDensityResult dataclass: strikes, density, quality, liquid_strike_count, atm_iv, warnings

    **moments.py:**
    compute_moments(density_result: ImpliedDensityResult) -> ImpliedMoments

    Cases:
    1. Full quality density: Returns mean, variance, skew, kurtosis computed via numerical integration
    2. Degraded density: Returns None for moments except atm_iv, quality=DEGRADED
    3. Log-normal benchmark: For known Black-76 prices, moments should match analytic log-normal moments within 5%

    ImpliedMoments dataclass: mean, variance, skew, kurtosis, atm_iv, quality, warnings
  </behavior>
  <implementation>
    **density.py** (Pattern 4 from research):
    1. Filter to liquid strikes: OI >= min_oi AND spread_pct <= max_spread_pct
    2. Always compute ATM IV as fallback (implied vol from ATM call price using scipy.optimize.brentq with Black-76)
    3. If liquid_count < min_liquid_strikes: return DEGRADED result with ATM IV only
    4. For FULL quality path:
       a. Compute implied vols from call prices (brentq inversion per strike)
       b. Calibrate SVI to implied vols (calibrate_svi from surface.py)
       c. Generate smooth call prices from SVI (svi_to_call_prices from surface.py) on a fine grid (200 points)
       d. Second derivative via np.gradient(np.gradient(C_fine, K_fine), K_fine)
       e. Density = exp(rT) * d2C/dK2
       f. Clip negatives to zero, normalize to integrate to ~1.0
       g. Validate: integral within 0.05 of 1.0, mean within 2% of forward price

    Helper function: _implied_vol_from_price(price, F, K, r, T) using scipy.optimize.brentq on the Black-76 formula

    **moments.py:**
    1. If density_result.quality != FULL: return ImpliedMoments with None for all moments except atm_iv
    2. Compute raw moments via scipy.integrate.trapezoid:
       - mean = integral(K * density * dK)
       - variance = integral((K - mean)^2 * density * dK)
       - skew = integral(((K - mean)/std)^3 * density * dK)
       - kurtosis = integral(((K - mean)/std)^4 * density * dK)
    3. Return ImpliedMoments with all values and quality=FULL
  </implementation>
</feature>

<verification>
1. `uv run pytest tests/test_bl_density.py tests/test_implied_moments.py -v` -- all tests pass
2. Log-normal benchmark test: B-L density from Black-76 prices recovers approximately log-normal shape
3. Degradation test: 5 liquid strikes -> quality=DEGRADED, only ATM IV returned
4. Normalization test: density integrates to 1.0 +/- 0.05
5. Moments stability: two slightly different inputs produce moments within 10% of each other
</verification>

<success_criteria>
- B-L extracts stable density from SVI-smoothed call prices
- Density integrates to ~1.0, mean within 2% of forward
- Graceful degradation to ATM IV when < 8 liquid strikes
- Implied moments (mean, variance, skew, kurtosis) computed from density
- All TDD tests pass (RED -> GREEN -> REFACTOR cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-infrastructure-options-math-engine/01-04-SUMMARY.md`
</output>
