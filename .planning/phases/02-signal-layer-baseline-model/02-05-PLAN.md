---
phase: 02-signal-layer-baseline-model
plan: 05
type: execute
wave: 4
depends_on:
  - 02-02
  - 02-04
files_modified:
  - src/hydra/model/walk_forward.py
  - src/hydra/model/evaluation.py
  - tests/test_walk_forward.py
  - tests/test_evaluation.py
autonomous: true
requirements:
  - MODL-02

must_haves:
  truths:
    - "PurgedWalkForwardSplit produces expanding-window train/test splits with configurable embargo gap (default 5 days)"
    - "No temporal leakage: train end + embargo gap < test start for every fold"
    - "Walk-forward engine trains model per fold, predicts OOS, applies slippage + position sizing + circuit breakers"
    - "Evaluation computes per-fold and aggregate metrics: Sharpe, returns, drawdown, hit rate, all slippage-adjusted"
    - "Backtest results include equity curve, trade log, and per-fold statistics"
  artifacts:
    - path: "src/hydra/model/walk_forward.py"
      provides: "PurgedWalkForwardSplit and WalkForwardEngine classes"
      exports: ["PurgedWalkForwardSplit", "WalkForwardEngine"]
    - path: "src/hydra/model/evaluation.py"
      provides: "BacktestMetrics computation and BacktestResult dataclass"
      exports: ["compute_backtest_metrics", "BacktestResult"]
    - path: "tests/test_walk_forward.py"
      provides: "Tests for walk-forward splitter and engine"
    - path: "tests/test_evaluation.py"
      provides: "Tests for backtest metrics computation"
  key_links:
    - from: "src/hydra/model/walk_forward.py"
      to: "src/hydra/model/baseline.py"
      via: "trains and predicts with BaselineModel per fold"
      pattern: "BaselineModel|model\\.train|model\\.predict"
    - from: "src/hydra/model/walk_forward.py"
      to: "src/hydra/risk/slippage.py"
      via: "applies estimate_slippage to every simulated trade"
      pattern: "estimate_slippage"
    - from: "src/hydra/model/walk_forward.py"
      to: "src/hydra/risk/position_sizing.py"
      via: "sizes positions with fractional_kelly + volume_capped_position"
      pattern: "fractional_kelly|volume_capped"
    - from: "src/hydra/model/walk_forward.py"
      to: "src/hydra/risk/circuit_breakers.py"
      via: "checks CircuitBreakerManager pre-trade"
      pattern: "CircuitBreakerManager|check_trade"
    - from: "src/hydra/model/evaluation.py"
      to: "scikit-learn metrics"
      via: "accuracy_score, roc_auc_score, log_loss for classification metrics"
      pattern: "accuracy_score|roc_auc_score|log_loss"
---

<objective>
Build the walk-forward backtesting engine with purged/embargoed splits and the evaluation module that computes slippage-adjusted backtest metrics. This is the validation gate -- if OOS Sharpe <= 0 after slippage, the project thesis needs re-examination.

Purpose: Rigorous out-of-sample validation of the divergence signal's predictive power. The walk-forward engine trains per fold, predicts OOS, applies realistic slippage/position sizing/circuit breakers, and produces metrics that determine whether to proceed to Phase 3.

Output: `src/hydra/model/walk_forward.py` and `src/hydra/model/evaluation.py`, tested.
</objective>

<execution_context>
@/Users/tristanfarmer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tristanfarmer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-signal-layer-baseline-model/02-RESEARCH.md
@.planning/phases/02-signal-layer-baseline-model/02-02-SUMMARY.md
@.planning/phases/02-signal-layer-baseline-model/02-04-SUMMARY.md
@src/hydra/model/baseline.py
@src/hydra/model/features.py
@src/hydra/risk/slippage.py
@src/hydra/risk/position_sizing.py
@src/hydra/risk/circuit_breakers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PurgedWalkForwardSplit and evaluation metrics with tests</name>
  <files>src/hydra/model/walk_forward.py, src/hydra/model/evaluation.py, tests/test_walk_forward.py, tests/test_evaluation.py</files>
  <action>
**src/hydra/model/walk_forward.py** -- `PurgedWalkForwardSplit`:

```python
class PurgedWalkForwardSplit:
    """Walk-forward cross-validator with embargo gap.

    Timeline per fold: [====TRAIN====][--EMBARGO--][==TEST==]

    Expanding window: train set grows each fold.
    Embargo gap: N trading days removed between train end and test start.
    """
    def __init__(
        self,
        n_splits: int = 5,
        embargo_days: int = 5,
        min_train_size: int = 252,  # ~1 year trading days
        test_size: int = 63,        # ~3 months
    ):
        ...

    def split(self, n_samples: int) -> list[tuple[np.ndarray, np.ndarray]]:
        """Return list of (train_indices, test_indices) tuples.

        Fold k train: [0, train_end_k]
        Fold k test: [train_end_k + embargo_days, train_end_k + embargo_days + test_size]

        Expanding: train_end grows by test_size each fold.
        """
        ...

    def get_n_splits(self) -> int:
        return self.n_splits
```

**src/hydra/model/evaluation.py**:

```python
@dataclass
class BacktestResult:
    """Results from walk-forward backtest."""
    sharpe_ratio: float           # annualized, slippage-adjusted
    total_return: float           # cumulative return after slippage
    max_drawdown: float           # maximum drawdown
    hit_rate: float               # fraction of correct directional predictions
    avg_return_per_trade: float   # average return per trade after slippage
    n_trades: int                 # total number of trades executed
    fold_sharpes: list[float]     # per-fold Sharpe ratios
    equity_curve: np.ndarray      # daily equity values
    trade_log: list[dict]         # individual trade records

def compute_backtest_metrics(
    returns: np.ndarray,          # daily returns (slippage-adjusted)
    predictions: np.ndarray,      # model predictions (0/1)
    actuals: np.ndarray,          # actual outcomes (0/1)
    fold_returns: list[np.ndarray] | None = None,
    risk_free_rate: float = 0.0,
) -> BacktestResult:
    """Compute all backtest metrics from daily returns.

    Sharpe = (mean_return - rf) / std_return * sqrt(252)
    Max drawdown from running max of equity curve.
    Hit rate = accuracy of directional prediction.
    """
    ...
```

**tests/test_walk_forward.py** (6+ tests):
1. **test_split_count**: n_splits=5 produces 5 (train, test) pairs
2. **test_no_overlap**: For every fold, max(train_idx) + embargo_days < min(test_idx)
3. **test_expanding_window**: Train set grows across folds (len(train_k+1) > len(train_k))
4. **test_embargo_gap**: Gap between train end and test start >= embargo_days
5. **test_min_train_size_respected**: First fold has at least min_train_size training samples
6. **test_insufficient_data_fewer_splits**: If n_samples too small for n_splits, return fewer folds

**tests/test_evaluation.py** (5+ tests):
1. **test_sharpe_positive_returns**: All positive returns -> Sharpe > 0
2. **test_sharpe_negative_returns**: All negative returns -> Sharpe < 0
3. **test_max_drawdown_calculation**: Known equity curve -> known max drawdown
4. **test_hit_rate_perfect**: All correct predictions -> hit_rate = 1.0
5. **test_hit_rate_random**: 50/50 predictions -> hit_rate ~= 0.5

Run all tests. All must pass.
  </action>
  <verify>`cd /Users/tristanfarmer/Documents/HYDRA && python -m pytest tests/test_walk_forward.py tests/test_evaluation.py -v` -- all tests pass</verify>
  <done>PurgedWalkForwardSplit produces correct expanding-window splits with embargo. BacktestResult computed correctly. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement WalkForwardEngine integrating model + risk stack</name>
  <files>src/hydra/model/walk_forward.py, src/hydra/model/__init__.py</files>
  <action>
Add `WalkForwardEngine` to `src/hydra/model/walk_forward.py`:

```python
class WalkForwardEngine:
    """Runs walk-forward backtest with full risk stack.

    Per fold:
    1. Train BaselineModel on train set
    2. Predict probabilities on test set
    3. For each test day:
       a. Check circuit breakers (skip if triggered)
       b. Compute position size via fractional Kelly + volume cap
       c. Compute slippage via estimate_slippage
       d. Record trade with slippage-adjusted return
    4. Compute per-fold metrics
    5. Aggregate across all folds

    Config:
    - prediction_horizon: int (default 5 days)
    - initial_capital: float (default 100000)
    - spread: float (default bid-ask spread for slippage)
    - daily_volume: float (default avg daily volume for slippage + sizing)
    - daily_volatility: float (default for slippage model)
    - contract_value: float (default value per contract)
    - circuit_breaker_config: dict (thresholds for 4 breakers)
    - kelly_fraction: float (default 0.5 = half-Kelly)
    - impact_coefficient: float (default 0.1 for slippage)
    """

    def __init__(self, config: dict | None = None):
        ...

    def run(
        self,
        X: np.ndarray,
        y: np.ndarray,
        prices: np.ndarray,
        feature_names: list[str] | None = None,
    ) -> BacktestResult:
        """Execute full walk-forward backtest.

        X: feature matrix (N, F)
        y: binary targets (N,)
        prices: price series for PnL computation (N,)
        feature_names: optional names for feature importance

        Returns BacktestResult with all metrics.
        """
        splitter = PurgedWalkForwardSplit(...)
        folds = splitter.split(len(X))

        all_returns = []
        all_predictions = []
        all_actuals = []
        fold_sharpes = []
        trade_log = []

        for train_idx, test_idx in folds:
            model = BaselineModel()
            model.train(X[train_idx], y[train_idx], feature_names)

            probas = model.predict_proba(X[test_idx])
            preds = (probas >= 0.5).astype(int)

            # Simulate trades with risk stack
            cb_manager = CircuitBreakerManager(self.config.get("circuit_breakers", {}))
            fold_returns_list = []

            for i, (pred, proba, actual) in enumerate(zip(preds, probas, y[test_idx])):
                # Check circuit breakers
                # Compute position size (fractional Kelly based on running win stats)
                # Compute slippage
                # Compute net return = raw_return - slippage
                # Record in trade_log
                ...

            fold_sharpes.append(compute_sharpe(fold_returns_list))
            all_returns.extend(fold_returns_list)
            all_predictions.extend(preds)
            all_actuals.extend(y[test_idx])

        return compute_backtest_metrics(
            np.array(all_returns), np.array(all_predictions),
            np.array(all_actuals), fold_returns=...,
        )
```

Update `src/hydra/model/__init__.py` to re-export `WalkForwardEngine`, `PurgedWalkForwardSplit`, `BacktestResult`.

The engine is the integration point: it uses BaselineModel (02-04), estimate_slippage (02-02), fractional_kelly + volume_capped_position (02-02), and CircuitBreakerManager (02-02).

Test with a small synthetic dataset to verify end-to-end: generate random features, random binary labels, random prices. Run WalkForwardEngine.run() and verify it returns a BacktestResult without crashing and with reasonable structure.
  </action>
  <verify>
```bash
cd /Users/tristanfarmer/Documents/HYDRA
python -m pytest tests/test_walk_forward.py tests/test_evaluation.py -v
python -c "
from hydra.model import WalkForwardEngine, BacktestResult
import numpy as np
# Smoke test
X = np.random.randn(500, 17)
y = np.random.randint(0, 2, 500)
prices = 100 + np.cumsum(np.random.randn(500) * 0.5)
engine = WalkForwardEngine()
result = engine.run(X, y, prices)
print(f'Sharpe: {result.sharpe_ratio:.3f}, Trades: {result.n_trades}, Folds: {len(result.fold_sharpes)}')
print('Walk-forward engine OK')
"
```
  </verify>
  <done>WalkForwardEngine integrates BaselineModel + slippage + Kelly sizing + circuit breakers. Runs end-to-end on synthetic data. Produces BacktestResult with Sharpe, drawdown, hit rate, trade log, equity curve. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/tristanfarmer/Documents/HYDRA
python -m pytest tests/test_walk_forward.py tests/test_evaluation.py -v
python -c "from hydra.model import WalkForwardEngine, PurgedWalkForwardSplit, BacktestResult; print('Import OK')"
# Full smoke test with synthetic data
python -c "
from hydra.model import WalkForwardEngine
import numpy as np
np.random.seed(42)
X = np.random.randn(500, 17)
y = np.random.randint(0, 2, 500)
prices = 100 + np.cumsum(np.random.randn(500) * 0.5)
result = WalkForwardEngine().run(X, y, prices)
assert hasattr(result, 'sharpe_ratio')
assert hasattr(result, 'fold_sharpes')
assert len(result.fold_sharpes) > 0
print('PASS: Walk-forward backtest engine works end-to-end')
"
```
</verification>

<success_criteria>
- PurgedWalkForwardSplit produces expanding-window splits with embargo gap
- No temporal leakage: train always before test with embargo buffer
- WalkForwardEngine runs full train-predict-risk loop per fold
- Every simulated trade has slippage applied via volume-adaptive model
- Position sizing uses fractional Kelly capped by volume
- Circuit breakers checked pre-trade and halt when triggered
- BacktestResult includes Sharpe, drawdown, hit rate, equity curve, trade log, per-fold Sharpes
- Engine runs successfully on synthetic data end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/02-signal-layer-baseline-model/02-05-SUMMARY.md`
</output>
